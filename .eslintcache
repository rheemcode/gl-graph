[{"C:\\Users\\rheen\\Documents\\Templates\\src\\index.tsx":"1","C:\\Users\\rheen\\Documents\\Templates\\src\\reportWebVitals.ts":"2","C:\\Users\\rheen\\Documents\\Templates\\src\\App.tsx":"3","C:\\Users\\rheen\\Documents\\Templates\\src\\reduxStore\\index.ts":"4","C:\\Users\\rheen\\Documents\\Templates\\src\\reducers\\index.ts":"5","C:\\Users\\rheen\\Documents\\Templates\\src\\WebGL\\GLContext.ts":"6","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\Tabs\\RenderTab.tsx":"7","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GLCanvas.tsx":"8","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\Tabs\\GraphTab.tsx":"9","C:\\Users\\rheen\\Documents\\Templates\\src\\WebGL\\GLShader.ts":"10","C:\\Users\\rheen\\Documents\\Templates\\src\\WebGL\\Buffer.ts":"11","C:\\Users\\rheen\\Documents\\Templates\\src\\WebGL\\GLRenderer.ts":"12","C:\\Users\\rheen\\Documents\\Templates\\src\\ShaderGraphWindow.tsx":"13","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\TabManager.tsx":"14","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\NodePanel.tsx":"15","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\InOutNode.tsx":"16","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\ContentContainer.tsx":"17","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\TitleBar.tsx":"18","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\Icons\\DoubleCircleIcon.tsx":"19","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\Node.tsx":"20","C:\\Users\\rheen\\Documents\\Templates\\src\\reducers\\nodesFilter.ts":"21","C:\\Users\\rheen\\Documents\\Templates\\src\\reduxStore\\hooks.ts":"22","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\ContextMenu.tsx":"23","C:\\Users\\rheen\\Documents\\Templates\\src\\Graph\\builtins.ts":"24","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\Builtins\\Builtins.tsx":"25","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\DataTypes\\DataTypes.tsx":"26","C:\\Users\\rheen\\Documents\\Templates\\src\\Utils\\getNodeComponent.tsx":"27","C:\\Users\\rheen\\Documents\\Templates\\src\\Utils\\helper.ts":"28","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\GLFuncs\\GLFuncs.tsx":"29","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\Menus.tsx":"30","C:\\Users\\rheen\\Documents\\Templates\\src\\WebGL\\Texture.ts":"31"},{"size":630,"mtime":1634762073602,"results":"32","hashOfConfig":"33"},{"size":426,"mtime":1620738366000,"results":"34","hashOfConfig":"33"},{"size":695,"mtime":1636552136264,"results":"35","hashOfConfig":"33"},{"size":364,"mtime":1635350893047,"results":"36","hashOfConfig":"33"},{"size":172,"mtime":1635348774287,"results":"37","hashOfConfig":"33"},{"size":7107,"mtime":1636490128101,"results":"38","hashOfConfig":"33"},{"size":706,"mtime":1636380195114,"results":"39","hashOfConfig":"33"},{"size":754,"mtime":1635950990540,"results":"40","hashOfConfig":"33"},{"size":65668,"mtime":1636552283698,"results":"41","hashOfConfig":"33"},{"size":3019,"mtime":1636475560704,"results":"42","hashOfConfig":"33"},{"size":2431,"mtime":1636476668111,"results":"43","hashOfConfig":"33"},{"size":3415,"mtime":1636551550759,"results":"44","hashOfConfig":"33"},{"size":322,"mtime":1634742906313,"results":"45","hashOfConfig":"33"},{"size":2637,"mtime":1636379453376,"results":"46","hashOfConfig":"33"},{"size":160,"mtime":1634678464084,"results":"47","hashOfConfig":"33"},{"size":2208,"mtime":1635595203809,"results":"48","hashOfConfig":"33"},{"size":711,"mtime":1634678521706,"results":"49","hashOfConfig":"33"},{"size":227,"mtime":1634678545747,"results":"50","hashOfConfig":"33"},{"size":364,"mtime":1634678330911,"results":"51","hashOfConfig":"33"},{"size":4529,"mtime":1636472069567,"results":"52","hashOfConfig":"33"},{"size":11293,"mtime":1637925373527,"results":"53","hashOfConfig":"33"},{"size":312,"mtime":1635349129113,"results":"54","hashOfConfig":"33"},{"size":4319,"mtime":1635943320891,"results":"55","hashOfConfig":"33"},{"size":1379,"mtime":1636374499005,"results":"56","hashOfConfig":"33"},{"size":10659,"mtime":1636377995228,"results":"57","hashOfConfig":"33"},{"size":12406,"mtime":1636472735315,"results":"58","hashOfConfig":"33"},{"size":9532,"mtime":1637925396869,"results":"59","hashOfConfig":"33"},{"size":6375,"mtime":1637925381912,"results":"60","hashOfConfig":"33"},{"size":85788,"mtime":1636545884273,"results":"61","hashOfConfig":"33"},{"size":4980,"mtime":1637919912955,"results":"62","hashOfConfig":"33"},{"size":1921,"mtime":1636551278476,"results":"63","hashOfConfig":"33"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"67"},"hjjorp",{"filePath":"68","messages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"70","messages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"72","messages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"74","messages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"76","messages":"77","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"67"},{"filePath":"79","messages":"80","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"81","messages":"82","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"67"},{"filePath":"84","messages":"85","errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"67"},{"filePath":"87","messages":"88","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"89","messages":"90","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"91","messages":"92","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"93","messages":"94","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"95","messages":"96","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"97","usedDeprecatedRules":"67"},{"filePath":"98","messages":"99","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"100","messages":"101","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"67"},{"filePath":"103","messages":"104","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"105","messages":"106","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"107","messages":"108","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"109"},{"filePath":"110","messages":"111","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"112","usedDeprecatedRules":"67"},{"filePath":"113","messages":"114","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"115","usedDeprecatedRules":"67"},{"filePath":"116","messages":"117","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"118","messages":"119","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"120","usedDeprecatedRules":"67"},{"filePath":"121","messages":"122","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"123","messages":"124","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"125","usedDeprecatedRules":"67"},{"filePath":"126","messages":"127","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"128","usedDeprecatedRules":"67"},{"filePath":"129","messages":"130","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"131","messages":"132","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"133","usedDeprecatedRules":"67"},{"filePath":"134","messages":"135","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"136","usedDeprecatedRules":"67"},{"filePath":"137","messages":"138","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"139","usedDeprecatedRules":"67"},{"filePath":"140","messages":"141","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},"C:\\Users\\rheen\\Documents\\Templates\\src\\index.tsx",["142"],"import ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport { Provider } from \"react-redux\";\r\n\r\nimport \"./index.css\"\r\nimport \"./style.css\"\r\nimport reducers from './reducers';\r\nimport store from './reduxStore';\r\n\r\n\r\n\r\nReactDOM.render(\r\n  <Provider store={store}>\r\n    <App />\r\n  </Provider>\r\n  ,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n",["143","144"],"C:\\Users\\rheen\\Documents\\Templates\\src\\reportWebVitals.ts",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\App.tsx",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\reduxStore\\index.ts",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\reducers\\index.ts",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\WebGL\\GLContext.ts",["145"],"import { off } from \"process\";\r\nimport { Vec2 } from \"Utils/helper\";\r\n\r\ndeclare interface GLShader extends WebGLShader { }\r\n\r\nexport declare interface GLProgram extends WebGLProgram { }\r\nexport declare interface GLBuffer extends WebGLBuffer { }\r\nexport declare interface GLTexture extends WebGLTexture { }\r\n\r\n// sorry i thought i was writing c++\r\n\r\nexport enum BufferType {\r\n    ELEMENT_ARRAY_BUFFER = WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER,\r\n    ARRAY_BUFFER = WebGL2RenderingContext.ARRAY_BUFFER,\r\n    UNIFORM_BUFFER = WebGL2RenderingContext.UNIFORM_BUFFER\r\n}\r\n\r\nexport enum BufferUsage {\r\n    STATIC_DRAW = WebGL2RenderingContext.STATIC_DRAW,\r\n    DYNAMIC_DRAW = WebGL2RenderingContext.DYNAMIC_DRAW,\r\n    STREAM_DRAW = WebGL2RenderingContext.STREAM_DRAW\r\n}\r\n\r\nexport enum ShaderType {\r\n    VERTEX = WebGL2RenderingContext.VERTEX_SHADER,\r\n    FRAGMENT = WebGL2RenderingContext.FRAGMENT_SHADER\r\n}\r\n\r\nexport enum ShaderParameter {\r\n    COMPILE_STATUS = WebGL2RenderingContext.COMPILE_STATUS,\r\n    LINK_STATUS = WebGL2RenderingContext.LINK_STATUS\r\n}\r\n\r\nexport enum GLDataType {\r\n    FLOAT = WebGL2RenderingContext.FLOAT,\r\n    INT = WebGL2RenderingContext.INT\r\n}\r\n\r\nexport enum PrimitiveMode {\r\n    LINES = WebGL2RenderingContext.LINES,\r\n    POINTS = WebGL2RenderingContext.POINTS,\r\n    TRIANGLES = WebGL2RenderingContext.TRIANGLES,\r\n    TRIANGLE_STRIP = WebGL2RenderingContext.TRIANGLE_STRIP,\r\n    TRIANGLE_FAN = WebGL2RenderingContext.TRIANGLE_FAN\r\n}\r\n\r\n\r\ndeclare type Attribs = \"aVertexPos\" | \"aTexCoord\"\r\n\r\nexport class GLContext {\r\n    private static glContext: WebGL2RenderingContext;\r\n\r\n    Create(context: WebGL2RenderingContext) {\r\n        GLContext.glContext = context;\r\n    }\r\n\r\n    static Viewport(x: number, y: number, width: number, height: number) {\r\n        GLContext.glContext.viewport(x, y, width, height);\r\n    }\r\n\r\n    static CreateProgram(): GLProgram {\r\n        return GLContext.glContext.createProgram() as GLProgram\r\n    }\r\n\r\n    static CreateShader(shaderType: ShaderType): GLShader {\r\n        let shader = GLContext.glContext.createShader(shaderType);\r\n        return shader as GLShader;\r\n    }\r\n\r\n    static ShaderSource(shader: GLShader, shaderSource: string) {\r\n        GLContext.glContext.shaderSource(shader, shaderSource);\r\n    }\r\n\r\n    static CompileShader(shader: GLShader) {\r\n        GLContext.glContext.compileShader(shader);\r\n    }\r\n\r\n    static AttachShader(program: GLProgram, shader: GLShader) {\r\n        GLContext.glContext.attachShader(program, shader);\r\n    }\r\n\r\n    static DetachShader(program: GLProgram, shader: GLShader) {\r\n        GLContext.glContext.detachShader(program, shader);\r\n    }\r\n\r\n    static DeleteShader(shader: GLShader) {\r\n        GLContext.glContext.deleteShader(shader);\r\n    }\r\n\r\n    static LinkProgram(program: GLProgram) {\r\n        GLContext.glContext.linkProgram(program);\r\n    }\r\n\r\n    static DeleteProgram(program: GLProgram) {\r\n        GLContext.glContext.deleteProgram(program);\r\n    }\r\n\r\n    static GetShaderParameter(shader: GLShader, pname: number) {\r\n        return GLContext.glContext.getShaderParameter(shader, pname);\r\n    }\r\n\r\n    static UseProgram(program: GLProgram) {\r\n        GLContext.glContext.useProgram(program);\r\n    }\r\n\r\n    static GetProgramParameter(shader: GLProgram, pname: number) {\r\n        return GLContext.glContext.getProgramParameter(shader, pname);\r\n    }\r\n\r\n\r\n    static GetShaderInfoLog(shader: GLShader) {\r\n        return GLContext.glContext.getShaderInfoLog(shader);\r\n    }\r\n\r\n    static CreateBuffer() {\r\n        return GLContext.glContext.createBuffer() as GLBuffer;\r\n    }\r\n\r\n    static BufferData(bufferType: BufferType, data: ArrayBuffer, usage: BufferUsage) {\r\n\r\n        GLContext.glContext.bufferData(bufferType, data, usage);\r\n    }\r\n\r\n    static SetTextureParams() {\r\n        GLContext.glContext.texParameteri(GLContext.glContext.TEXTURE_2D, this.glContext.TEXTURE_WRAP_S, GLContext.glContext.CLAMP_TO_EDGE);\r\n        this.glContext.texParameteri(this.glContext.TEXTURE_2D, this.glContext.TEXTURE_WRAP_T, this.glContext.CLAMP_TO_EDGE);\r\n        this.glContext.texParameteri(this.glContext.TEXTURE_2D, this.glContext.TEXTURE_MIN_FILTER, this.glContext.LINEAR);\r\n    }\r\n\r\n    static SetTexture(width: number, height: number, buffer: TexImageSource) {\r\n        GLContext.glContext.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, GLContext.glContext.RGBA, width, height, 0, GLContext.glContext.RGBA, GLContext.glContext.UNSIGNED_BYTE, buffer);\r\n    }\r\n\r\n    static CreateTexture(): GLTexture | null {\r\n        return this.glContext.createTexture();\r\n    }\r\n\r\n    static ActivateTexture(index: number) {\r\n        GLContext.glContext.activeTexture(GLContext.glContext.TEXTURE0 + index);\r\n    }\r\n\r\n    static BindTexture(texture: GLTexture) {\r\n        GLContext.glContext.bindTexture(GLContext.glContext.TEXTURE_2D, texture);\r\n    }\r\n\r\n    static GetAttribLocation(program: GLProgram, name: Attribs) {\r\n        return GLContext.glContext.getAttribLocation(program, name);\r\n    }\r\n\r\n    static SetTextureIndex(program: GLProgram, name: string, index: number) {\r\n        const location = GLContext.glContext.getUniformLocation(program, name);\r\n        GLContext.glContext.uniform1i(location, index);\r\n    }\r\n\r\n    static SetUniformFloat(program: GLProgram, name: string, value: number) {\r\n        const location = GLContext.glContext.getUniformLocation(program, name);\r\n        GLContext.glContext.uniform1f(location, value);\r\n    }\r\n\r\n    static SetUniformVec2(program: GLProgram, name: string, value: Vec2) {\r\n        const location = GLContext.glContext.getUniformLocation(program, name);\r\n        GLContext.glContext.uniform2f(location, value.x, value.y);\r\n    }\r\n\r\n    static VertexAttribPointer(attribPos: number, count: number, dataType: GLDataType, normalized: boolean, stride: number, offset: number) {\r\n        GLContext.glContext.vertexAttribPointer(attribPos, count, dataType, normalized, stride, offset);\r\n    }\r\n\r\n    static EnableVertexAtrribArray(attrib: number) {\r\n        GLContext.glContext.enableVertexAttribArray(attrib);\r\n    }\r\n\r\n    static BindBuffer(bufferType: BufferType, buffer: GLBuffer) {\r\n        GLContext.glContext.bindBuffer(bufferType, buffer);\r\n    }\r\n\r\n    static DeleteBuffer(bufferType: GLBuffer) {\r\n        GLContext.glContext.deleteBuffer(bufferType);\r\n    }\r\n\r\n    static SetClearColor(red: number, green: number, blue: number, alpha: number) {\r\n        GLContext.glContext.clearColor(red, green, blue, alpha);\r\n    }\r\n\r\n    static ClearColorBuffer() {\r\n        GLContext.glContext.clear(GLContext.glContext.COLOR_BUFFER_BIT);\r\n    }\r\n\r\n    static GetErrors() {\r\n        return GLContext.glContext.getError();\r\n    }\r\n\r\n    static DrawArrays(mode: PrimitiveMode, count: number) {\r\n        GLContext.glContext.drawArrays(this.glContext.TRIANGLE_STRIP, 0, 4);\r\n    }\r\n}\r\n\r\nexport class GLErrors {\r\n    cache: any[] = []\r\n    GetError(count = 1) {\r\n        if (this.cache.length) {\r\n            return this.cache.pop() as any;\r\n        }\r\n    }\r\n\r\n    AddError(error: any) {\r\n        this.cache.push(error)\r\n    }\r\n}\r\n\r\nexport let g_glErrors = new GLErrors();","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\Tabs\\RenderTab.tsx",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GLCanvas.tsx",["146","147"],"import React from \"react\";\r\nimport { useEffect, useRef } from \"react\";\r\nimport { GLContext } from \"../WebGL/GLContext\";\r\n\r\ndeclare interface GLCanvasProps {\r\n    createContextFn: Function\r\n}\r\n\r\n\r\nexport const GLCanvas = React.forwardRef<any, GLCanvasProps>((props, canvasElement) => {\r\n\r\n    useEffect(() => {\r\n        let canvasRef = canvasElement as React.RefObject<HTMLCanvasElement>;\r\n        let canvas = canvasRef.current as HTMLCanvasElement;\r\n        const _glContext = canvas.getContext(\"webgl2\") as WebGL2RenderingContext;\r\n        const glContext = new GLContext();\r\n        glContext.Create(_glContext);\r\n\r\n        props.createContextFn(glContext);\r\n    }, []);\r\n\r\n    return <canvas ref={canvasElement} className=\"GLCanvas\"></canvas>;\r\n});\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\Tabs\\GraphTab.tsx",["148","149","150","151","152","153","154","155","156","157","158","159"],"import {\r\n    NodeDispatch,\r\n    ConnectorState,\r\n    ConnectorDispatch,\r\n    AppState,\r\n    defaultNodeState,\r\n    NodeInput,\r\n    UID,\r\n    GLType,\r\n    NodeState\r\n} from \"../../reducers/nodesFilter\";\r\nimport { INodeRefs } from \"Componets/GraphComponents/Node\";\r\nimport React, { useEffect, useRef, useState } from \"react\";\r\nimport { generateUID, getDistanceToMouse, Vec2 } from \"Utils/helper\";\r\nimport { useAppDispatch, useAppSelector } from \"../../reduxStore/hooks\";\r\nimport { shaderGraphWindowRef } from \"../../ShaderGraphWindow\";\r\nimport { getNodeComponent } from \"../../Utils/getNodeComponent\";\r\nimport { ContextMenu } from \"../GraphComponents/ContextMenu\";\r\n\r\nexport let scale = 1;\r\nconst scaleWeight = 1.1;\r\nconst scaleLimit = 2;\r\n\r\nlet activeNodeElement: INodeRefs | null = null;\r\nlet lastActiveNodeElement: INodeRefs | null = null;\r\nlet activeNodeConnector: NodeConnectorState | null = null;\r\n\r\nlet tryingToConnectNode = false;\r\n\r\nexport let oldMousePos: Vec2 = { x: 0, y: 0 }\r\nlet mousePos: Vec2 = { x: 0, y: 0 }\r\n\r\n\r\ninterface ConnectionState {\r\n    isInside: boolean;\r\n    isValid: boolean;\r\n    outputNodeIndex: number;\r\n    inputNodeIndex?: number; // in the case of multiple input/output nodes\r\n    inputNodeId?: UID;\r\n    outputNodeId?: UID;\r\n    type: \"Input\" | \"Output\";\r\n}\r\n\r\nconst INVALID_INDEX = -1;\r\n/** for checking null values */\r\nconst DEFAULT_INDEX = 0;\r\n\r\n\r\n/** Validates connection state and updates output type of node element  receiving input `i.e vec2() + vec2() -> vec2 type`*/\r\nconst validateConnectionState = (elementRef = activeNodeElement, nodeStates: AppState, connectionState: ConnectionState, nodeDispatchFn: React.Dispatch<NodeDispatch>) => {\r\n    if (connectionState.isInside && (connectionState.type === \"Input\")) {\r\n        if (connectionState.inputNodeId === connectionState.outputNodeId) {\r\n            connectionState.isValid = false;\r\n            return;\r\n        }\r\n\r\n        if (elementRef) {\r\n            const inputType = elementRef.inputDataTypes;\r\n            const node = nodeStates.nodeStates.find((val) => val.id === elementRef.id);\r\n            \r\n            \r\n            if (inputType.find((val) => val === activeNodeElement?.outputDataType)) {\r\n                if (node?.inputs) {\r\n                    if (elementRef.name === \"texture\" || elementRef.name === \"textureProj\" || elementRef.name === \"texelFetch\" || elementRef.name === \"textureGather\" || elementRef.name === \"textureSize\") {\r\n                        if (connectionState.inputNodeIndex === 0) {\r\n                            if (activeNodeElement?.outputDataType === \"Sampler2D\") {\r\n                                connectionState.isValid = true;\r\n                                return;\r\n                            }\r\n\r\n                            connectionState.isValid = false;\r\n                            return;\r\n                        }\r\n\r\n                        if (connectionState.inputNodeIndex === 1) {\r\n                            if (activeNodeElement?.outputDataType === \"Vector2\") {\r\n                                connectionState.isValid = true;\r\n                                return;\r\n                            }\r\n\r\n                            connectionState.isValid = false;\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                \r\n                if (!node?.inputs) {\r\n                    \r\n                    connectionState.isInside = true;\r\n                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: activeNodeElement?.outputDataType as GLType } });\r\n                    return;\r\n                }\r\n            }\r\n            else connectionState.isValid = false\r\n\r\n            if (node) {\r\n                if (node.inputs) {\r\n\r\n\r\n\r\n                    if (elementRef.name === \"abs\"\r\n                        || elementRef.name === \"ceil\"\r\n                        || elementRef.name === \"floor\"\r\n                        || elementRef.name === \"fract\"\r\n                        || elementRef.name === \"inversesqrt\"\r\n                        || elementRef.name === \"log\"\r\n                        || elementRef.name === \"log2\"\r\n                        || elementRef.name === \"round\"\r\n                        || elementRef.name === \"roundEven\"\r\n                        || elementRef.name === \"sign\"\r\n                        || elementRef.name === \"sqrt\"\r\n                        || elementRef.name === \"exp\"\r\n                        || elementRef.name === \"exp2\"\r\n                        || elementRef.name === \"acos\"\r\n                        || elementRef.name === \"cos\"\r\n                        || elementRef.name === \"cosh\"\r\n                        || elementRef.name === \"acosh\"\r\n                        || elementRef.name === \"sin\"\r\n                        || elementRef.name === \"asin\"\r\n                        || elementRef.name === \"sinh\"\r\n                        || elementRef.name === \"asinh\"\r\n                        || elementRef.name === \"tan\"\r\n                        || elementRef.name === \"atan\"\r\n                        || elementRef.name === \"tanh\"\r\n                        || elementRef.name === \"atanh\"\r\n                        || elementRef.name === \"degrees\"\r\n                        || elementRef.name === \"radians\"\r\n                        || elementRef.name === \"transpose\"\r\n                        || elementRef.name === \"inverse\"\r\n                        || elementRef.name === \"determinant\"\r\n                        || elementRef.name === \"normalize\"\r\n                        || elementRef.name === \"length\"\r\n                    ) {\r\n                        if (activeNodeElement) {\r\n                            if (elementRef.name === \"transpose\" || elementRef.name === \"inverse\" || elementRef.name === \"determinant\") {\r\n                                const inputDataType = activeNodeElement.outputDataType;\r\n                                if (inputDataType === \"Matrix3\" || inputDataType === \"Matrix4\") {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n\r\n                                connectionState.isValid = false;\r\n                                return;\r\n                            }\r\n                            if (elementRef.name === \"normalize\") {\r\n                                const inputDataType = activeNodeElement.outputDataType;\r\n                                if (inputDataType === \"Vector2\" || \"Vector3\" || \"Vector4\") {\r\n                                    connectionState.isValid = true;\r\n                                    \r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n\r\n                                connectionState.isValid = false;\r\n                                return;\r\n                            }\r\n\r\n                            if (elementRef.name === \"length\") {\r\n                                \r\n                                const inputDataType = activeNodeElement.outputDataType;\r\n                                if (inputDataType === \"Vector2\" || \"Vector3\" || \"Vector4\") {\r\n                                    connectionState.isValid = true;\r\n                                    \r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Float\" } });\r\n                                    return;\r\n                                }\r\n\r\n                                connectionState.isValid = false;\r\n                                return;\r\n                            }\r\n\r\n                            const inputDataType = activeNodeElement.outputDataType;\r\n                            nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                            connectionState.isValid = true;\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n\r\n                    if (elementRef.name === \"add\" || elementRef.name === \"substract\" || elementRef.name === \"multiply\" || elementRef.name === \"divide\") {\r\n                        // if node already has a first input check if second input type would be valid `i.e 'vec2() + vec3()' would be invalid`\r\n                        if (node.inputs[0] && connectionState.inputNodeIndex === 1) {\r\n\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[0].id);\r\n                            if (elementRef.name === \"multiply\") {\r\n                                if (inputNodeElem) {\r\n                                    const inputDataType = inputNodeElem.nodeDataType;\r\n                                    if ((inputDataType === \"Matrix3\") && (activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                        connectionState.isValid = true;\r\n                                        nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Vector3\" } });\r\n                                        return;\r\n                                    }\r\n                                    if ((inputDataType === \"Matrix4\") && (activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                        connectionState.isValid = true;\r\n                                        nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Vector4\" } });\r\n                                        return;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if (inputNodeElem) {\r\n                                const inputDataType = inputNodeElem.nodeDataType;\r\n                                if ((inputDataType === \"Integer\" || inputDataType === \"Float\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Float\" } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Integer\" || inputDataType === \"Float\") && (activeNodeElement?.outputDataType === \"Vector2\" || activeNodeElement?.outputDataType === \"Vector3\" || activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: activeNodeElement?.outputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector2\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector2\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector3\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector4\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n\r\n                            }\r\n                        }\r\n                        if (node.inputs[1] && connectionState.inputNodeIndex === 0) {\r\n\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[1].id);\r\n                            if (inputNodeElem) {\r\n                                const inputDataType = inputNodeElem.nodeDataType;\r\n                                if ((inputDataType === \"Integer\" || inputDataType === \"Float\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Float\" } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Integer\" || inputDataType === \"Float\") && (activeNodeElement?.outputDataType === \"Vector2\" || activeNodeElement?.outputDataType === \"Vector3\" || activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: activeNodeElement?.outputDataType as GLType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector2\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector2\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector3\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector4\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    if (elementRef.name === \"isinf\" || elementRef.name === \"isnan\") {\r\n\r\n                        if (activeNodeElement) {\r\n                            const inputDataType = activeNodeElement.outputDataType;\r\n                            connectionState.isValid = true;\r\n                            nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Boolean\" } });\r\n                            return;\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    if (elementRef.name === \"mod\" || elementRef.name === \"pow\" || elementRef.name === \"step\") {\r\n\r\n                        if (node.inputs[0] && connectionState.inputNodeIndex === 1) {\r\n\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[0].id);\r\n                            if (inputNodeElem) {\r\n                                const inputDataType = inputNodeElem.nodeDataType;\r\n                                if ((inputDataType === \"Integer\" || inputDataType === \"Float\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Float\" } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector2\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector2\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector3\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector4\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n\r\n                            }\r\n                        }\r\n                        if (node.inputs[1] && connectionState.inputNodeIndex === 0) {\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[1].id);\r\n                            if (inputNodeElem) {\r\n                                const inputDataType = inputNodeElem.nodeDataType;\r\n                                if ((inputDataType === \"Integer\" || inputDataType === \"Float\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Float\" } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector2\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector2\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector3\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector4\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\" || activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n                    if (elementRef.name === \"cross\" || elementRef.name === \"dot\" || elementRef.name === \"distance\" || elementRef.name === \"equal\" || elementRef.name === \"notEqual\" || elementRef.name === \"facefoward\" || elementRef.name === \"reflect\" || elementRef.name === \"refract\") {\r\n\r\n                        if (node.inputs[0] && connectionState.inputNodeIndex === 1) {\r\n\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[0].id);\r\n                            if (inputNodeElem) {\r\n                                let inputDataType = inputNodeElem.nodeDataType;\r\n                                \r\n                                if ((inputDataType === \"Vector2\") && (activeNodeElement?.outputDataType === \"Vector2\")) {\r\n                                    connectionState.isValid = true;\r\n                                    inputDataType = elementRef.name === \"dot\" || elementRef.name === \"distance\" ? \"Float\" : inputNodeElem.nodeDataType;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector3\") && (activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    inputDataType = elementRef.name === \"dot\" || elementRef.name === \"distance\" ? \"Float\" : inputNodeElem.nodeDataType;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector4\") && (activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    inputDataType = elementRef.name === \"dot\" || elementRef.name === \"distance\" ? \"Float\" : inputNodeElem.nodeDataType;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n\r\n                            }\r\n                        }\r\n                        if (node.inputs[1] && connectionState.inputNodeIndex === 0) {\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[1].id);\r\n                            if (inputNodeElem) {\r\n                                let inputDataType = inputNodeElem.nodeDataType;\r\n                                \r\n                                if ((inputDataType === \"Vector2\") && (activeNodeElement?.outputDataType === \"Vector2\")) {\r\n                                    connectionState.isValid = true;\r\n                                    inputDataType = elementRef.name === \"dot\" || elementRef.name === \"distance\" ? \"Float\" : inputNodeElem.nodeDataType;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector3\") && (activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    inputDataType = elementRef.name === \"dot\" || elementRef.name === \"distance\" ? \"Float\" : inputNodeElem.nodeDataType;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector4\") && (activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    inputDataType = elementRef.name === \"dot\" || elementRef.name === \"distance\" ? \"Float\" : inputNodeElem.nodeDataType;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        return;\r\n                    }\r\n\r\n                    if (elementRef.name === \"matrixCompMult\" || elementRef.name === \"outerProduct\") {\r\n\r\n                        if (node.inputs[0] && connectionState.inputNodeIndex === 1) {\r\n\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[0].id);\r\n                            if (inputNodeElem) {\r\n                                const inputDataType = inputNodeElem.nodeDataType;\r\n                                if ((inputDataType === \"Matrix3\") && (activeNodeElement?.outputDataType === \"Matrix3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Matrix4\") && (activeNodeElement?.outputDataType === \"Matrix4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n\r\n                            }\r\n                        }\r\n                        if (node.inputs[1] && connectionState.inputNodeIndex === 0) {\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[1].id);\r\n                            if (inputNodeElem) {\r\n                                const inputDataType = inputNodeElem.nodeDataType;\r\n                                if ((inputDataType === \"Matrix3\") && (activeNodeElement?.outputDataType === \"Matrix3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Matrix4\") && (activeNodeElement?.outputDataType === \"Matrix4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        return;\r\n                    }\r\n                    if (elementRef.name === \"smoothstep\" || elementRef.name === \"clamp\") {\r\n                        if (node.inputs[0] && (connectionState.inputNodeIndex === 1 || connectionState.inputNodeIndex === 2)) {\r\n\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[0].id);\r\n                            if (inputNodeElem) {\r\n                                const inputDataType = inputNodeElem.nodeDataType;\r\n                                if ((inputDataType === \"Integer\" || inputDataType === \"Float\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Float\" } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector2\") && (activeNodeElement?.outputDataType === \"Vector2\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector3\") && (activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector4\") && (activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n\r\n                            }\r\n                        }\r\n\r\n                        if (node.inputs[1] && (connectionState.inputNodeIndex === 0 || connectionState.inputNodeIndex === 2)) {\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[1].id);\r\n                            if (inputNodeElem) {\r\n                                const inputDataType = inputNodeElem.nodeDataType;\r\n                                if ((inputDataType === \"Integer\" || inputDataType === \"Float\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Float\" } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector2\") && (activeNodeElement?.outputDataType === \"Vector2\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector3\") && (activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector4\") && (activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    if (elementRef.name === \"min\" || elementRef.name === \"max\") {\r\n                        if (node.inputs[0] && connectionState.inputNodeIndex === 1) {\r\n\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[0].id);\r\n                            if (inputNodeElem) {\r\n                                const inputDataType = inputNodeElem.nodeDataType;\r\n                                if ((inputDataType === \"Integer\" || inputDataType === \"Float\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Float\" } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector2\") && (activeNodeElement?.outputDataType === \"Vector2\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector3\") && (activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector4\") && (activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n\r\n                            }\r\n                        }\r\n                        if (node.inputs[1] && connectionState.inputNodeIndex === 0) {\r\n                            const inputNodeElem = nodeStates.nodeStates.find((val) => val.id === node.inputs[1].id);\r\n                            if (inputNodeElem) {\r\n                                const inputDataType = inputNodeElem.nodeDataType;\r\n                                if ((inputDataType === \"Integer\" || inputDataType === \"Float\") && (activeNodeElement?.outputDataType === \"Integer\" || activeNodeElement?.outputDataType === \"Float\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: \"Float\" } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector2\") && (activeNodeElement?.outputDataType === \"Vector2\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector3\") && (activeNodeElement?.outputDataType === \"Vector3\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                if ((inputDataType === \"Vector4\") && (activeNodeElement?.outputDataType === \"Vector4\")) {\r\n                                    connectionState.isValid = true;\r\n                                    nodeDispatchFn({ type: \"UPDATE_OUTPUT_TYPE\", payload: { ...defaultNodeState, id: elementRef.id, nodeDataType: inputDataType } });\r\n                                    return;\r\n                                }\r\n                                connectionState.isValid = false;\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if mouse is trying to connect a Node\r\n * @returns ConnectionState Object\r\n */\r\nconst testForConnection = (event: React.MouseEvent, elementRef = activeNodeElement): ConnectionState => {\r\n    let outputNode = elementRef?.nodeOutputConnectorRef.current as HTMLElement;\r\n    let inputNodeRef = elementRef?.nodeInputConnectorRef\r\n\r\n\r\n    for (let i = 0; i < outputNode.childElementCount; i++) {\r\n\r\n        let node = outputNode.children[i].children[1]; // circle Node\r\n        let outputedNodebb = outputNode.children[i].children[2].getBoundingClientRect();\r\n\r\n        let bb = node.getBoundingClientRect();\r\n        bb = new DOMRect(bb.x, bb.y, outputedNodebb.right - bb.left, bb.height);\r\n        let distance = getDistanceToMouse({ x: event.pageX, y: event.pageY }, bb);\r\n        if (distance === 0) {\r\n            return { isInside: true, outputNodeIndex: i, isValid: true, outputNodeId: elementRef?.id as UID, type: \"Output\" };\r\n        }\r\n    }\r\n\r\n    if (inputNodeRef) {\r\n        let inputNode = inputNodeRef.current;\r\n        for (let i = 0; i < inputNode.childElementCount; i++) {\r\n\r\n            let node = inputNode.children[i].children[0];\r\n            let outputedNodebb = inputNode.children[i].children[1].getBoundingClientRect();\r\n\r\n            let bb = node.getBoundingClientRect();\r\n\r\n            bb = new DOMRect(bb.x, outputedNodebb.y, outputedNodebb.right - bb.left, outputedNodebb.height);\r\n            let distance = getDistanceToMouse({ x: event.pageX, y: event.pageY }, bb);\r\n\r\n            if (distance === 0) {\r\n                return { isInside: true, inputNodeIndex: i, isValid: true, inputNodeId: elementRef?.id as UID, outputNodeId: \"\", outputNodeIndex: 0, type: \"Input\" };\r\n            }\r\n        }\r\n    }\r\n\r\n    return { isInside: false, isValid: false, outputNodeIndex: INVALID_INDEX, inputNodeIndex: INVALID_INDEX, type: \"Input\" };\r\n}\r\n\r\nconst handleMouseDraggingConnector = (event: React.MouseEvent, dispatchFn: React.Dispatch<ConnectorDispatch>) => {\r\n    const connectionResult = testForConnection(event);\r\n    if (connectionResult.isInside && (connectionResult.type === \"Output\")) {\r\n        dispatchFn({ type: \"FINDING\", payload: { type: \"Output\", inputIndex: INVALID_INDEX, outputIndex: connectionResult.outputNodeIndex, dragging: true, connected: false, elementRef: activeNodeElement?.nodeOutputConnectorRef } })\r\n    }\r\n}\r\n\r\nconst handleNodeSelection = (elementRefs: INodeRefs, connectorDispatch: React.Dispatch<ConnectorDispatch>) => {\r\n\r\n    return (event: React.MouseEvent) => {\r\n        switch (event.type) {\r\n            case \"mousedown\":\r\n                {\r\n                    if (activeNodeElement) {\r\n                        const elem = activeNodeElement.elementRef.current as HTMLDivElement;\r\n                        elem.style.border = \"none\";\r\n                    }\r\n                    activeNodeElement = elementRefs;\r\n                    // check if trying to start a connection\r\n                    handleMouseDraggingConnector(event, connectorDispatch);\r\n\r\n                    const elem = activeNodeElement.elementRef.current as HTMLDivElement;\r\n                    elem.style.border = \"solid\";\r\n\r\n                    oldMousePos = { x: event.pageX, y: event.pageY };\r\n                    mousePos = oldMousePos;\r\n                    break;\r\n                }\r\n            case \"mouseup\":\r\n                {\r\n                    break;\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\nconst handleNodeConnection = (elementRefs: INodeRefs, nodeDispatchFn: React.Dispatch<NodeDispatch>, connectorDispatch: React.Dispatch<ConnectorDispatch>, nodeStates: AppState, connectorState: ConnectorState) => {\r\n    return (event: React.MouseEvent) => {\r\n        switch (event.type) {\r\n            case \"mousemove\": {\r\n                if (connectorState.dragging) {\r\n\r\n                    // check if mouse if trying to connect a node\r\n                    const connectionResult = testForConnection(event, elementRefs);\r\n\r\n                    // validateConnectionState(elementRefs, nodeStates, connectionResult, nodeDispatchFn);\r\n                    if (connectionResult.isInside) {\r\n                        if (connectionResult.type === \"Input\") {\r\n                            connectorDispatch({ type: \"CONNECTED\", payload: { type: \"Input\", outputIndex: connectorState.outputIndex, inputIndex: connectionResult.inputNodeIndex as number, dragging: true, connected: true, elementRef: activeNodeElement?.elementRef } })\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n            case \"mouseup\": {\r\n                if (connectorState.connected) {\r\n                    // handles when mouse was released on trying to connect to a node\r\n\r\n                    const activeNode = activeNodeElement as INodeRefs;\r\n                    const connectionResult = testForConnection(event, elementRefs);\r\n                    validateConnectionState(elementRefs, nodeStates, connectionResult, nodeDispatchFn);\r\n                    if (connectionResult.isInside && connectionResult.isValid) {\r\n                        nodeDispatchFn(\r\n                            {\r\n                                type: \"UPDATE_NODE\",\r\n                                payload: {\r\n                                    ...defaultNodeState,\r\n                                    id: elementRefs.id,\r\n                                    props:\r\n                                    {\r\n                                        x: 0, y: 0,\r\n                                        refs: elementRefs,\r\n                                        nodeDataValue: { value: 0 }\r\n                                    },\r\n                                    inputs: [{\r\n                                        id: activeNodeElement?.id as UID,\r\n                                        index: connectorState.inputIndex,\r\n                                        inputData: { value: 0 },\r\n                                        nodeConnectorRef: defaultNodeState.inputs[0].nodeConnectorRef,\r\n                                        ref: activeNodeElement as INodeRefs\r\n                                    }]\r\n                                }\r\n                            });\r\n\r\n                        nodeDispatchFn(\r\n                            {\r\n                                type: \"UPDATE_NODE\",\r\n                                payload: {\r\n                                    ...defaultNodeState,\r\n                                    id: activeNode.id,\r\n                                    props:\r\n                                    {\r\n                                        x: 0, y: 0,\r\n                                        refs: activeNode,\r\n                                        nodeDataValue: { value: 0 }\r\n                                    },\r\n                                    outputs: [{\r\n                                        id: elementRefs.id as UID,\r\n                                        index: connectorState.inputIndex,\r\n                                        outputData: { value: 0 },\r\n                                        ref: elementRefs as INodeRefs\r\n                                    }]\r\n                                }\r\n                            });\r\n                    }\r\n                    connectorDispatch({ type: \"RELEASE\", payload: { type: \"NULL\", inputIndex: INVALID_INDEX, outputIndex: INVALID_INDEX, dragging: false, connected: false } })\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst updateNodePosition = (nodeElem: NodeState, nodeState: NodeState[]) => {\r\n    if (nodeElem !== undefined) {\r\n        // handle Node movement/connection if seleted node has outputs\r\n        if (nodeElem.inputs.length > 0) {\r\n\r\n            for (let i = 0; i < nodeElem.inputs.length; i++) {\r\n                const inputNode = nodeElem.inputs[i];\r\n                if (inputNode) {\r\n\r\n                    const nodeConnector = inputNode.nodeConnectorRef.current;\r\n                    let pathStart: Vec2 = { x: 0, y: 0 };\r\n                    let pathEnd: Vec2 = { x: 0, y: 0 };\r\n\r\n                    if (nodeElem.props.refs) {\r\n                        if (nodeElem.props.refs.nodeInputConnectorRef) {\r\n                            const connector = nodeElem.props.refs.nodeInputConnectorRef.current.children[inputNode.index];\r\n                            const rect = connector?.children[0].getBoundingClientRect() as DOMRect;\r\n                            pathEnd = { x: rect.left, y: (rect.y + 2) }\r\n                        }\r\n                        // assuming its only has one output node;\r\n                        const outputer = inputNode.ref?.nodeOutputConnectorRef.current.children[0];\r\n                        if (outputer) {\r\n                            const rect = outputer.children[2].getBoundingClientRect();\r\n                            pathStart = { x: rect.right - 5, y: (rect.y + 2) };\r\n                            nodeConnector?.setAttribute(\"d\", `M${pathStart.x} ${pathStart.y} C${pathStart.x + 60} ${pathStart.y}, ${pathEnd.x - 60} ${pathEnd.y + 2}, ${pathEnd.x} ${pathEnd.y}`);\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // handle Node movement/connection if seleted node has outputs\r\n        if (nodeElem.outputs.length > 0) {\r\n\r\n            for (let outputNode of nodeElem.outputs) {\r\n\r\n                let index = 0;\r\n                if (outputNode) {\r\n                    // find ouputed element\r\n                    let outputedNodeElem: NodeInput = defaultNodeState.inputs[0];\r\n                    let outputedNode = nodeState.find((elem) => {\r\n                        if (elem.id === outputNode.id) {\r\n                            for (let i = 0; i < elem.inputs.length; i++) {\r\n                                if (elem.inputs[i])\r\n                                    if (elem.inputs[i].index === outputNode.index) {\r\n                                        outputedNodeElem = elem.inputs[i];\r\n                                        return true;\r\n                                    }\r\n                            }\r\n                        }\r\n\r\n                        return false;\r\n                    });\r\n\r\n                    if (!outputedNode) {\r\n                        continue;\r\n                    }\r\n\r\n                    const nodeConnector = outputedNodeElem.nodeConnectorRef.current as SVGPathElement;\r\n                    index++;\r\n                    let pathStart: Vec2 = { x: 0, y: 0 };\r\n                    let pathEnd: Vec2 = { x: 0, y: 0 };\r\n\r\n                    if (nodeElem.props.refs) {\r\n                        if (nodeElem.props.refs.nodeOutputConnectorRef) {\r\n                            const connector = nodeElem.props.refs.nodeOutputConnectorRef.current.children[0];\r\n                            const rect = connector?.children[2].getBoundingClientRect() as DOMRect;\r\n                            pathStart = { x: rect.right - 5, y: (rect.y + 2) }\r\n                        }\r\n                        // assuming its only has one output node;\r\n                        const inputer = outputNode.ref?.nodeInputConnectorRef?.current.children[outputNode.index] as HTMLElement;\r\n                        const rect = inputer.children[0].getBoundingClientRect();\r\n                        pathEnd = { x: rect.left, y: (rect.y + 2) };\r\n\r\n                        nodeConnector?.setAttribute(\"d\", `M${pathStart.x} ${pathStart.y} C${pathStart.x + 60} ${pathStart.y}, ${pathEnd.x - 60} ${pathEnd.y + 2}, ${pathEnd.x} ${pathEnd.y}`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\nconst handleNodeMovement = (event: React.MouseEvent, dispatchFn: Function, nodeState: AppState, connectorState: ConnectorState) => {\r\n\r\n    mousePos = { x: event.pageX, y: event.pageY };\r\n\r\n    if (connectorState.dragging) {\r\n\r\n        let pathNode = defaultNodeConnectorRef.current as SVGPathElement;\r\n        if (pathNode) {\r\n            let connector = activeNodeElement?.nodeOutputConnectorRef.current.children[connectorState.outputIndex];\r\n            let rect = connector?.children[2].getBoundingClientRect() as DOMRect;\r\n\r\n            pathNode.setAttribute(\"d\", `M${(rect.right)} ${(rect.y + 2)} C${(rect.right) + 60} ${(rect.y - 2)}, ${event.pageX - 60} ${event.pageY}, ${event.pageX} ${event.pageY}`);\r\n        }\r\n        return;\r\n    }\r\n    else {\r\n        let pathNode = defaultNodeConnectorRef.current as SVGPathElement;\r\n        if (pathNode) {\r\n            pathNode.setAttribute(\"d\", `M0 0 C 0 0, 0 0, 0 0`);\r\n        }\r\n    }\r\n\r\n    if (!activeNodeElement)\r\n        return;\r\n\r\n    // set cursor to grabbing on root node\r\n    let rootRef = shaderGraphWindowRef.current as HTMLDivElement;\r\n    rootRef.style.cursor = \"grabbing\";\r\n\r\n    const elem = activeNodeElement.elementRef.current as HTMLDivElement;\r\n    elem.style.left = elem.offsetLeft + ((event.pageX - oldMousePos.x) / scale) + \"px\";\r\n    elem.style.top = elem.offsetTop + ((event.pageY - oldMousePos.y) / scale) + \"px\";\r\n\r\n    const nodeElem = nodeState.nodeStates.find((element) => element.id === activeNodeElement?.id) as NodeState;\r\n    updateNodePosition(nodeElem, nodeState.nodeStates);\r\n\r\n    oldMousePos = { x: event.pageX, y: event.pageY };\r\n}\r\n\r\nconst handleNodeDeselection = (event: React.MouseEvent) => {\r\n\r\n    if (event.target != activeNodeConnector?.ref.current) {\r\n        if (activeNodeConnector) {\r\n            if (activeNodeConnector.ref.current) {\r\n                activeNodeConnector.ref.current.classList.remove(\"Active\");\r\n                activeNodeConnector = null;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    hideContext(event);\r\n    if (lastActiveNodeElement?.elementRef !== activeNodeElement?.elementRef) {\r\n        if (!lastActiveNodeElement)\r\n            return;\r\n\r\n        let elem = lastActiveNodeElement.elementRef.current as HTMLDivElement\r\n        elem.style.border = \"none\"\r\n    }\r\n    if (event.target === graphPanelRef.current) {\r\n        if (!lastActiveNodeElement)\r\n            return;\r\n        let elem = lastActiveNodeElement.elementRef.current as HTMLDivElement\r\n        elem.style.border = \"none\";\r\n    }\r\n}\r\n\r\nconst handleZooming = (nodeStates: NodeState[]) => {\r\n    return (event: React.WheelEvent) => {\r\n        if ((event.target === graphPanelRef.current?.children[0]) || (event.target === graphPanelRef.current?.children[1]) || (event.target === graphPanelRef.current)) {\r\n            let elem = graphPanelRef.current as HTMLDivElement;\r\n            let container = elem.children[1] as HTMLDivElement;\r\n\r\n            if (event.deltaY < 0) {\r\n                scale *= scaleWeight;\r\n                if (scale >= scaleLimit) {\r\n                    scale = scaleLimit;\r\n                }\r\n                container.style.transform = `scale(${scale})`;\r\n                const connectorContainer = graphPanelRef.current.children[0];\r\n                connectorContainer.setAttribute(\"stroke-width\", `calc(4px * ${scale})`);\r\n            }\r\n            else {\r\n                scale /= scaleWeight;\r\n\r\n                if (scale <= 0.1) {\r\n                    scale = 0.1;\r\n                }\r\n\r\n                const connectorContainer = graphPanelRef.current.children[0];\r\n                connectorContainer.setAttribute(\"stroke-width\", `calc(4px * ${scale})`);\r\n                container.style.transform = `scale(${scale})`;\r\n            }\r\n\r\n\r\n            for (let nodeElem of nodeStates) {\r\n                updateNodePosition(nodeElem, nodeStates);\r\n            }\r\n\r\n        }\r\n    }\r\n}\r\nconst contextMenuRef = React.createRef<HTMLDivElement>();\r\nlet contextVisible = false;\r\n\r\nexport const hideContext = (event: React.MouseEvent) => {\r\n    if (event.button !== 0)\r\n        return;\r\n    const contextElem = contextMenuRef.current as HTMLDivElement;\r\n    if (contextVisible)\r\n        contextVisible = false;\r\n\r\n\r\n\r\n    if (event.target === contextMenuRef.current) {\r\n        contextVisible = true\r\n        return;\r\n    }\r\n    contextElem.classList.remove(\"Active\");\r\n}\r\n\r\nexport const showContext = (pos = mousePos) => {\r\n    const contextElem = contextMenuRef.current as HTMLDivElement;\r\n    contextVisible = !contextVisible;\r\n\r\n    contextElem.style.left = (pos.x) + \"px\";\r\n    contextElem.style.top = (pos.y) + \"px\";\r\n    contextElem.classList.toggle(\"Active\");\r\n\r\n}\r\n\r\nconst handleKeyEvents = (nodeDispatchFn: React.Dispatch<NodeDispatch>, setNodeCount: React.Dispatch<React.SetStateAction<number>>) => {\r\n    return (event: KeyboardEvent) => {\r\n        if (event.ctrlKey) {\r\n            if (event.code === \"KeyA\") {\r\n                showContext();\r\n            }\r\n\r\n            if (event.shiftKey && event.code === \"KeyD\") {\r\n                event.preventDefault();\r\n                nodeDispatchFn(\r\n                    {\r\n                        type: \"ADD_NODE\",\r\n                        payload: {\r\n                            ...defaultNodeState, id: generateUID(),\r\n                            nodeName: lastActiveNodeElement?.name as string, props: {\r\n                                x: mousePos.x, y: mousePos.y,\r\n                                refs: null, nodeDataValue: { value: 0 },\r\n\r\n                            },\r\n                            inputs: []\r\n                        },\r\n                    });\r\n\r\n                setNodeCount((val) => val += 1);\r\n\r\n            }\r\n        }\r\n\r\n        // handle deleting node\r\n        if (event.code == \"Delete\") {\r\n            if (activeNodeConnector != null) {\r\n                nodeDispatchFn(\r\n                    {\r\n                        type: \"REMOVE_NODE_INPUT\",\r\n                        payload: {\r\n                            ...defaultNodeState,\r\n                            id: activeNodeConnector.nodeProps?.id as UID,\r\n                            inputs: [{\r\n                                id: \"\",\r\n                                index: activeNodeConnector.index,\r\n                                inputData: { value: 0 },\r\n                                nodeConnectorRef: defaultNodeState.inputs[0].nodeConnectorRef,\r\n                                ref: activeNodeElement as INodeRefs\r\n                            }]\r\n                        }\r\n                    });\r\n\r\n                activeNodeConnector = null\r\n                setNodeCount((value) => value -= 1);\r\n                setNodeCount((value) => value += 1);\r\n\r\n\r\n            }\r\n            if (lastActiveNodeElement != null) {\r\n                nodeDispatchFn(\r\n                    {\r\n                        type: \"REMOVE_NODE\",\r\n                        payload: {\r\n                            ...defaultNodeState,\r\n                            id: lastActiveNodeElement.id,\r\n                        }\r\n                    });\r\n                activeNodeElement = null;\r\n                lastActiveNodeElement = null;\r\n                setNodeCount((value) => value -= 1)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface NodeConnectorProps {\r\n    start: Vec2;\r\n    end: Vec2;\r\n    curveAmount: number,\r\n    index: number;\r\n    nodeProps: INodeRefs | null,\r\n}\r\n\r\ninterface NodeConnectorState {\r\n    index: number;\r\n    ref: React.RefObject<SVGPathElement>;\r\n    nodeProps: INodeRefs | null;\r\n}\r\n\r\nconst NodeConnector = React.forwardRef<SVGPathElement, NodeConnectorProps>((props, ref) => {\r\n\r\n    const nodeState = useAppSelector((state) => state.nodesFilter);\r\n    const _ref = useRef<SVGPathElement>(SVGPathElement.prototype)\r\n\r\n    useEffect(() => {\r\n\r\n        nodeState.nodeStates.forEach((el) => {\r\n            if (el.id === props.nodeProps?.id) {\r\n                for (let input of el.inputs) {\r\n                    if (input) {\r\n                        if (input.index === props.index) {\r\n                            input.nodeConnectorRef = _ref;\r\n\r\n                        };\r\n                    };\r\n                };\r\n            };\r\n        });\r\n    });\r\n\r\n    return (\r\n        <path className={\"NodeConnector\"} onMouseDown={() => {\r\n\r\n            let state: NodeConnectorState = { index: props.index, ref: _ref, nodeProps: props.nodeProps };\r\n            activeNodeConnector = state;\r\n            const elem = _ref.current;\r\n            if (elem)\r\n                elem.classList.add(\"Active\");\r\n\r\n        }} ref={ref ? ref : _ref} d=\r\n            {`M${props.start.x} ${props.start.y} \r\n              C${props.start.x + 60} ${props.start.y}, \r\n               ${props.end.x - 60} ${props.end.y}, \r\n               ${props.end.x} ${props.end.y}`}\r\n        />\r\n    );\r\n});\r\n\r\nconst defaultNodeConnectorRef = React.createRef<SVGPathElement>();\r\n//let connectorRefs: React.RefObject<SVGPathElement>[] = []\r\n\r\nconst ConnectorContainer = () => {\r\n    const nodeState = useAppSelector((state) => state.nodesFilter);\r\n    let count = 0;\r\n\r\n\r\n    return (\r\n        <svg className={\"ConnectorContainer\"} width=\"100vw\" height=\"100vh\" fill=\"transparent\" stroke=\"grey\" strokeWidth={\"4px\"} >\r\n            <NodeConnector start={{ x: 0, y: 0 }} index={0} end={{ x: 0, y: 0 }} nodeProps={null} curveAmount={1} ref={defaultNodeConnectorRef} />\r\n            {\r\n                nodeState.nodeStates.flatMap((value, index) => {\r\n\r\n                    let result = []\r\n                    if (value.inputs.length > 0) {\r\n                        for (let inputNode of value.inputs) {\r\n\r\n                            if (inputNode) {\r\n                                let pathStart: Vec2 = { x: 0, y: 0 };\r\n                                let pathEnd: Vec2 = { x: 0, y: 0 };\r\n\r\n                                if (value.props.refs) {\r\n                                    if (value.props.refs.nodeInputConnectorRef) {\r\n                                        const connector = value.props.refs.nodeInputConnectorRef.current.children[inputNode.index];\r\n                                        const rect = connector?.children[0].getBoundingClientRect() as DOMRect;\r\n                                        pathEnd = { x: rect.left, y: (rect.y + 2) }\r\n                                    }\r\n                                    // assuming its only has one output node;\r\n                                    const outputer = inputNode.ref?.nodeOutputConnectorRef.current.children[0];\r\n                                    if (outputer) {\r\n                                        const rect = outputer.children[2].getBoundingClientRect();\r\n                                        pathStart = { x: rect.right - 5, y: (rect.y) };\r\n\r\n                                    }\r\n                                }\r\n\r\n\r\n                                //      inputNode.nodeConnectorRef = connectorRefs[index];\r\n                                result.push(<NodeConnector key={index + count} index={value.inputs.findIndex((val) => { if (val) return (val.id == inputNode.id && val.index == inputNode.index) })} nodeProps={value.props.refs} start={pathStart} end={pathEnd} curveAmount={1} />)\r\n                                count++;\r\n                            };\r\n\r\n                        };\r\n                    };\r\n\r\n                    return result;\r\n                })\r\n            }\r\n        </svg>\r\n    );\r\n};\r\n\r\nexport const GraphTab = () => {\r\n    const nodeState = useAppSelector((state) => state.nodesFilter);\r\n    const connectorState = useAppSelector((state) => state.connectorFilter);\r\n    const [nodeCount, setNodeCount] = useState(0);\r\n\r\n    const nodesDispatch: React.Dispatch<NodeDispatch> = useAppDispatch();\r\n    const connectorDispatch: React.Dispatch<ConnectorDispatch> = useAppDispatch();\r\n\r\n    useEffect(() => {\r\n        window.addEventListener(\"keydown\", handleKeyEvents(nodesDispatch, setNodeCount));\r\n    }, []);\r\n\r\n\r\n    useEffect(() => {\r\n        if (contextVisible) {\r\n            contextVisible = false;\r\n            const contextElem = contextMenuRef.current as HTMLDivElement;\r\n            contextElem.classList.remove(\"Active\");\r\n        };\r\n    });\r\n    return (\r\n        <div ref={graphTabRef} className=\"GraphTab\">\r\n            <ContextMenu onClickFn={setNodeCount} ref={contextMenuRef} />\r\n            <div ref={graphPanelRef} className=\"GraphPanel\"\r\n                onWheel={handleZooming(nodeState.nodeStates)}\r\n                onMouseMove={(event) => { handleNodeMovement(event, nodesDispatch, nodeState, connectorState) }}\r\n                onMouseUp={() => {\r\n                    tryingToConnectNode = false;\r\n                    lastActiveNodeElement = activeNodeElement;\r\n                    activeNodeElement = null;\r\n                    if (connectorState.dragging)\r\n                        connectorDispatch({ type: \"RELEASE\", payload: { type: \"NULL\", outputIndex: INVALID_INDEX, inputIndex: INVALID_INDEX, dragging: false, connected: false } });\r\n                }}\r\n\r\n                onContextMenu={(event) => {\r\n                    switch (event.button) {\r\n                        case 2: // right mouse button \r\n                            {\r\n                                event.preventDefault();\r\n                                showContext();\r\n                            };\r\n                    };\r\n                }}\r\n\r\n                onMouseDown={handleNodeDeselection}\r\n            >\r\n\r\n                <ConnectorContainer />\r\n                <div className=\"PanelContainer\">\r\n                    {\r\n                        nodeState.nodeStates.map((value, index) => getNodeComponent(value, handleNodeSelection, handleNodeConnection))\r\n                    }\r\n                </div>\r\n\r\n            </div>\r\n        </div >);\r\n\r\n};\r\n\r\nexport const graphTabRef = React.createRef<HTMLDivElement>();\r\nconst graphPanelRef = React.createRef<HTMLDivElement>();\r\n\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\WebGL\\GLShader.ts",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\WebGL\\Buffer.ts",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\WebGL\\GLRenderer.ts",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\ShaderGraphWindow.tsx",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\TabManager.tsx",["160","161","162"],"import React, { useState } from \"react\";\r\nimport { shaderGraphWindowRef } from \"../ShaderGraphWindow\";\r\nimport { GLContext } from \"../WebGL/GLContext\";\r\nimport { graphTabRef, GraphTab } from \"./Tabs/GraphTab\";\r\nimport { RenderTab, glCanvasRef } from \"./Tabs/RenderTab\";\r\n\r\ninterface WindowProps {\r\n    width: number;\r\n    height: number;\r\n    aspectRatio?: number;\r\n}\r\n\r\nlet [windowWidth, windowHeight] = [window.innerWidth, window.innerHeight];\r\n\r\nconst TabSplit = React.forwardRef<any, {}>((props, ref) => {\r\n    return <div className=\"TabSplit\" ref={ref} ></div >\r\n});\r\n\r\n\r\nexport const TabManager: React.FC = () => {\r\n    const splitTabRef = React.createRef<HTMLDivElement>();\r\n\r\n    let splitOffset = window.innerWidth * 0.5;\r\n    let dragging = false;\r\n\r\n    const computeSplitPos = (event: React.MouseEvent) => {\r\n        if (!dragging)\r\n            return;\r\n\r\n        let mouseX = splitOffset >= 30 ? event.movementX : event.movementX <= 0 ? 0 : event.movementX;\r\n        splitOffset += mouseX;\r\n\r\n        const node = splitTabRef.current as HTMLDivElement;\r\n        node.style.left = `${splitOffset}px`;\r\n        onResize();\r\n    }\r\n\r\n    const onStartDrag = (event: React.MouseEvent<HTMLDivElement>) => {\r\n        if (event.target == splitTabRef.current) {\r\n            let windowRef = shaderGraphWindowRef.current as HTMLDivElement;\r\n            windowRef.style.cursor = \"w-resize\";\r\n            dragging = true;\r\n        }\r\n    }\r\n\r\n    const onEndDrag = () => {\r\n        dragging = false;\r\n        let windowRef = shaderGraphWindowRef.current as HTMLDivElement;\r\n        windowRef.style.cursor = \"auto\";\r\n    }\r\n\r\n    const onResize = () => {\r\n        windowWidth = window.innerWidth;\r\n        windowHeight = window.innerHeight;\r\n\r\n        let ratio = windowWidth / windowHeight;\r\n        let computedWidth = splitOffset;\r\n        let computedHeight = computedWidth / ratio;\r\n        let canvas = glCanvasRef.current as HTMLCanvasElement;\r\n        canvas.width = computedWidth;\r\n        canvas.height = computedHeight;\r\n        canvas.style.width = computedWidth + \"px\";\r\n        canvas.style.height = computedHeight + \"px\";\r\n\r\n        let graphTab = graphTabRef.current as HTMLDivElement;\r\n        graphTab.style.width = (windowWidth - computedWidth) + \"px\";\r\n        GLContext.Viewport(0, 0, computedWidth, windowHeight);\r\n    }\r\n\r\n    window.onresize = onResize;\r\n\r\n    return (\r\n        <div className=\"TabManager\" onMouseDown={onStartDrag} onMouseUp={onEndDrag} onMouseMove={computeSplitPos}>\r\n            <RenderTab />\r\n            <TabSplit ref={splitTabRef} />\r\n            <GraphTab />\r\n        </div >\r\n    );\r\n}\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\NodePanel.tsx",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\InOutNode.tsx",["163"],"import React from \"react\"\r\nimport { CSSProperties } from \"react\"\r\nimport { DoubleCircleIcon } from \"../Icons/DoubleCircleIcon\"\r\n\r\ninterface NodeProps {\r\n    type: \"Input\" | \"Output\"\r\n    values: string[];\r\n    count: number;\r\n}\r\n\r\nexport const ConnectorNode = React.forwardRef<HTMLDivElement, NodeProps>((props, ref) => {\r\n    let elems = []\r\n    const style: CSSProperties = {\r\n        display: \"flex\",\r\n        marginBottom: \".2em\",\r\n        alignItems: \"center\"\r\n    }\r\n    switch (props.type) {\r\n        case \"Input\": {\r\n            for (var i = 0; i < props.count; i++) {\r\n                elems.push(\r\n                    <div key={i} style={style}>\r\n                        <div style={{ backgroundColor: \"grey\", position: \"absolute\", width: \"1.4em\", height: \".25rem\", left: \"0\" }}></div>\r\n                        <DoubleCircleIcon />\r\n                        <p>{props.values[i]}</p>\r\n                    </div>\r\n                )\r\n            }\r\n            break;\r\n        }\r\n\r\n        case \"Output\": {\r\n            for (var i = 0; i < props.count; i++) {\r\n                elems.push(\r\n                    <div key={i} id={`{i}`} style={{ ...style, justifyContent: \"flex-end\" }} >\r\n                        <p>{props.values[i]}</p>\r\n                        <DoubleCircleIcon />\r\n                        <div style={{ backgroundColor: \"grey\", position: \"absolute\", width: \"1.4em\", height: \".25rem\", right: \"0\" }}></div>\r\n                    </div >\r\n                )\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    return (\r\n        <div ref={ref} className={props.type + \"Node\"}>\r\n            {elems}\r\n        </div>\r\n    )\r\n});\r\n\r\ninterface InputProps {\r\n    onChangeFn: (event: React.ChangeEvent<HTMLInputElement>) => void;\r\n}\r\n\r\nexport const TextInputNode: React.FC<InputProps> = (props) => {\r\n    return (\r\n        <div className=\"TextInputNode\">\r\n            <input type=\"text\" name=\"\" id=\"\" onChange={props.onChangeFn} />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport const BoolInputNode: React.FC<InputProps> = (props) => {\r\n    return (\r\n        <div className=\"BoolInputNode\">\r\n            <input type=\"checkbox\" onChange={props.onChangeFn} name=\"\" value=\"unchecked\" id=\"\" />\r\n        </div>\r\n    )\r\n}\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\ContentContainer.tsx",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\TitleBar.tsx",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\Icons\\DoubleCircleIcon.tsx",[],["164","165"],"C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\Node.tsx",["166","167"],"import React, { useEffect } from \"react\";\r\nimport { useRef } from \"react\";\r\nimport { AppState, ConnectorDispatch, ConnectorState, GLType, defaultNodeState, NodeDispatch, NodeState, UID } from \"reducers/nodesFilter\";\r\nimport { useAppDispatch, useAppSelector } from \"reduxStore/hooks\";\r\n\r\nexport type NodeClickFn = (nodeRefs: INodeRefs, dispathFn: React.Dispatch<ConnectorDispatch>) => (event: React.MouseEvent) => void;\r\nexport type ConnectorFn = (elementRefs: INodeRefs, nodeDispatchFn: React.Dispatch<NodeDispatch>, connectorDispatch: React.Dispatch<ConnectorDispatch>, nodeState: AppState, connectorState: ConnectorState) => (event: React.MouseEvent) => void;\r\n\r\n\r\ntype NodeCategory = \"Builtins\" | \"Data Types\" | \"Math\" | \"Trigonometry\" | \"Vector\" | \"Matrix\" | \"Texture\";\r\n\r\nexport interface INodeRefs {\r\n    id: UID;\r\n    name: string;\r\n    nodeCategory: NodeCategory;\r\n    outputDataType: GLType;\r\n    inputDataTypes: GLType[],\r\n    elementRef: React.MutableRefObject<HTMLDivElement>;\r\n    nodeOutputConnectorRef: React.MutableRefObject<HTMLDivElement>;\r\n    nodeInputConnectorRef: React.MutableRefObject<HTMLDivElement> | null;\r\n}\r\n\r\nexport interface NodeProps {\r\n    id: UID;\r\n    x: number;\r\n    y: number;\r\n    value: string;\r\n    nodeRefs: INodeRefs | null;\r\n    clickFn: NodeClickFn;\r\n    connectorFn: ConnectorFn;\r\n    computeNodeValueFn: (n: NodeState[]) => string[];\r\n};\r\n\r\n// Dumb! why not include useRef here instead of repeating in every component\r\nexport const Node = React.forwardRef<HTMLDivElement, NodeProps>((props, ref) => {\r\n    const connectorDispatch: React.Dispatch<ConnectorDispatch> = useAppDispatch();\r\n    const nodeDispatch: React.Dispatch<NodeDispatch> = useAppDispatch();\r\n    const connectorState: ConnectorState = useAppSelector((state) => state.connectorFilter);\r\n    const nodeState: AppState = useAppSelector((state) => state.nodesFilter);\r\n\r\n    useEffect(() => {\r\n        const thisElem = nodeState.nodeStates.find((val) => val.id === props.id);\r\n        if (props.nodeRefs) {\r\n            if (props.nodeRefs.outputDataType === \"Any\" || props.nodeRefs.outputDataType === \"Vector\" || props.nodeRefs.outputDataType === \"Matrix\") {\r\n                props.nodeRefs.outputDataType = thisElem?.nodeDataType as GLType;\r\n\r\n            }\r\n\r\n        }\r\n        const outputConnector = props.nodeRefs?.nodeOutputConnectorRef.current;\r\n        const inputConnector = props.nodeRefs?.nodeInputConnectorRef?.current;\r\n        outputConnector?.children[0].children[1].children[1].setAttribute(\"fill\", \"transparent\");\r\n\r\n        if (inputConnector?.children) {\r\n            for (let childNode of inputConnector?.children) {\r\n                childNode.children[1].children[1].setAttribute(\"fill\", \"transparent\");\r\n            }\r\n        }\r\n\r\n\r\n        if (thisElem?.outputs) {\r\n            if (thisElem?.outputs.length) {\r\n                if (thisElem?.outputs[0].id || thisElem?.outputs.length > 1) {\r\n                    outputConnector?.children[0].children[1].children[1].setAttribute(\"fill\", \"grey\");\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        if (thisElem?.inputs) {\r\n            for (let i = 0; i < thisElem.inputs.length; i++) {\r\n                if (thisElem.inputs[i]) {\r\n                    inputConnector?.children[thisElem.inputs[i].index].children[1].children[1].setAttribute(\"fill\", \"grey\");\r\n                }\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n    useEffect(() => {\r\n        nodeDispatch({ type: \"UPDATE_PROPS\", payload: { ...defaultNodeState, id: props.id, nodeDataType: props.nodeRefs?.outputDataType as GLType, computeNodeValueFn: props.computeNodeValueFn, props: { x: 0, y: 0, refs: props.nodeRefs, nodeDataValue: { value: props.value } } } })\r\n    }, [/*props.nodeRefs?.elementRef*/])\r\n\r\n    return (\r\n        <div onMouseDown={props.clickFn(props.nodeRefs as INodeRefs, connectorDispatch)}\r\n            onMouseUp={props.connectorFn(props.nodeRefs as INodeRefs, nodeDispatch, connectorDispatch, nodeState, connectorState)}\r\n            //    onMouseEnter={props.connectorFn(props.nodeRefs as INodeRefs, nodeDispatch, connectorDispatch, connectorState)}\r\n            onMouseMove={props.connectorFn(props.nodeRefs as INodeRefs, nodeDispatch, connectorDispatch, nodeState, connectorState)}\r\n\r\n            ref={props.nodeRefs?.elementRef}\r\n            id={`${props.id}`}\r\n            key={props.id}\r\n            className={`Node`}\r\n            style={{ left: `${props.x}px`, top: `${props.y}px` }}\r\n        >\r\n            {props.children}\r\n        </div>\r\n    );\r\n});\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\reducers\\nodesFilter.ts",["168","169","170","171","172"],"import { INodeRefs } from \"Componets/GraphComponents/Node\";\r\nimport React from \"react\";\r\n\r\n\r\ninterface Vector2 {\r\n    x: FloatType,\r\n    y: FloatType;\r\n};\r\n\r\ninterface Vector3 {\r\n    x: FloatType,\r\n    y: FloatType,\r\n    z: FloatType;\r\n};\r\n\r\ninterface Vector4 {\r\n    x: FloatType,\r\n    y: FloatType,\r\n    z: FloatType;\r\n    w: FloatType;\r\n}\r\n\r\ninterface Matrix3 {\r\n    m0: Vector3;\r\n    m1: Vector3;\r\n    m2: Vector3;\r\n}\r\n\r\ninterface Matrix4 {\r\n    m0: Vector4,\r\n    m1: Vector4,\r\n    m2: Vector4,\r\n    m3: Vector4,\r\n}\r\nexport type AnyType = any;\r\nexport type BoolType = Boolean;\r\nexport type IntType = number;\r\nexport type FloatType = number;\r\nexport type Vector2Type = Vector2;\r\nexport type Vector3Type = Vector3;\r\nexport type Vector4Type = Vector4;\r\nexport type Matrix3Type = Matrix3;\r\nexport type Matrix4Type = Matrix4;\r\n\r\nexport type UID = string;\r\n\r\nexport interface NodeData {\r\n    value: string | FloatType | IntType | BoolType | Vector2Type | Vector3Type | Vector4Type | Matrix3Type | Matrix4Type;\r\n}\r\n\r\nexport interface NodeInput {\r\n    id: UID;\r\n    index: number;\r\n    ref: INodeRefs | null,\r\n    nodeConnectorRef: React.RefObject<SVGPathElement>;\r\n    inputData: NodeData;\r\n}\r\n\r\n//probably redundant\r\ninterface NodeOutput {\r\n    id: UID;\r\n    index: number;\r\n    ref: INodeRefs | null\r\n    outputData: NodeData\r\n}\r\n\r\ninterface NodeProps {\r\n    x: number;\r\n    y: number;\r\n    refs: INodeRefs | null,\r\n    nodeDataValue: NodeData;\r\n}\r\nexport type GLType = \"Any\" | \"Sampler2D\" | \"Integer\" | \"Float\" | \"Boolean\" | \"Vector\" | \"Vector2\" | \"Vector3\" | \"Vector4\" | \"Matrix\" | \"Matrix3\" | \"Matrix4\"\r\n\r\n\r\nexport interface NodeState {\r\n    id: UID;\r\n    nodeName: string;\r\n    nodeDataType: GLType,\r\n    props: NodeProps;\r\n    inputs: NodeInput[]\r\n    outputs: NodeOutput[]\r\n    computeNodeValueFn: (nodeStates: NodeState[]) => string[];\r\n}\r\n\r\nexport interface ConnectorState {\r\n    type: \"Input\" | \"Output\" | \"NULL\";\r\n    inputIndex: number;\r\n    outputIndex: number;\r\n    dragging: boolean;\r\n    connected: boolean;\r\n    elementRef?: React.RefObject<HTMLDivElement>;\r\n\r\n}\r\n\r\ntype NODE_ACTION = \"ADD_NODE\" | \"REMOVE_NODE\" | \"UPDATE_NODE\" | \"UPDATE_PROPS\" | \"UPDATE_NODE_VALUE\" | \"UPDATE_OUTPUT_TYPE\" | \"REMOVE_NODE_INPUT\";\r\ntype CONNECTOR_ACTION = \"FINDING\" | \"CONNECTED\" | \"RELEASE\"\r\n\r\nexport interface NodeDispatch {\r\n    type: NODE_ACTION;\r\n    payload: NodeState;\r\n}\r\n\r\nexport interface ConnectorDispatch {\r\n    type: CONNECTOR_ACTION;\r\n    payload: ConnectorState;\r\n}\r\n\r\nexport interface AppState {\r\n    nodeStates: NodeState[]\r\n}\r\n\r\nconst initialState: AppState = { nodeStates: [] };\r\n\r\nexport const defaultNodeState: NodeState = {\r\n    id: \"\",\r\n    nodeName: \"\",\r\n    nodeDataType: \"Any\",\r\n    props:\r\n    {\r\n        x: 0, y: 0,\r\n        refs: null,\r\n        nodeDataValue: { value: 0 }\r\n    },\r\n\r\n    computeNodeValueFn: (s) => [\"\"],\r\n    inputs: [\r\n        {\r\n            id: \"\",\r\n            index: 0,\r\n            inputData: { value: 0 },\r\n            nodeConnectorRef: React.createRef(),\r\n            ref: null\r\n        }],\r\n    outputs: [\r\n        {\r\n            id: \"\",\r\n            index: 0, // TODO: handle nodes with multiple output\r\n            outputData: { value: 0 },\r\n            ref: null\r\n        }]\r\n}\r\nconst initialConnectorState: ConnectorState = { type: \"NULL\", outputIndex: -1, inputIndex: -1, dragging: false, connected: false }\r\n\r\n/**\r\n * recursively updates the node element values\r\n * @param nodeStates node state\r\n * @param nodeElem updated node elements\r\n */\r\nconst updateNodeValue = (nodeStates: NodeState[], nodeElem: NodeState) => {\r\n\r\n    // iterate over node Elements output\r\n    for (let i = 0; i < nodeElem.outputs.length; i++) {\r\n        if (nodeElem.outputs[i].id) {\r\n            // find ouputed node Element in node state\r\n            const outputElem = nodeStates.find((value) => {\r\n                if (value)\r\n                    return value.id === nodeElem.outputs[i].id\r\n            });\r\n\r\n            if (outputElem) {\r\n                // find the output index of the oupting element \r\n                let inputedElem = outputElem.inputs.find((value) => {\r\n                    if (value) {\r\n                        return (nodeElem.id === value.id) && (nodeElem.outputs[i].index === value.index);\r\n                    }\r\n\r\n                    return false;\r\n                })\r\n\r\n                if (inputedElem) {\r\n                    // update the input value to the latest and the ouput value of the outputed element based on the input\r\n                    inputedElem.inputData.value = nodeElem.props.nodeDataValue.value;\r\n                    const [nodeValue, nodeValueVar] = outputElem.computeNodeValueFn(nodeStates)\r\n                    outputElem.props.nodeDataValue.value = nodeValueVar;\r\n                }\r\n\r\n                // remove default outputs or invalid outputs\r\n                outputElem.outputs = outputElem.outputs.filter((val) => val.id);\r\n\r\n                // if the outputed element also has outputs then update them as well\r\n                if (outputElem.outputs.length > 1) {\r\n                    updateNodeValue(nodeStates, outputElem);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const connectorFilter = (state = initialConnectorState, action: ConnectorDispatch): ConnectorState => {\r\n    switch (action.type) {\r\n        case \"FINDING\": {\r\n            return action.payload;\r\n        }\r\n        case \"CONNECTED\": {\r\n            return action.payload;\r\n        }\r\n        case \"RELEASE\": {\r\n            return action.payload;\r\n        }\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport const nodesFilter = (state = initialState, action: NodeDispatch): AppState => {\r\n    switch (action.type) {\r\n        case \"ADD_NODE\": {\r\n            state.nodeStates.push(action.payload);\r\n            \r\n            return { ...state, nodeStates: state.nodeStates };\r\n        }\r\n        case \"REMOVE_NODE\": {\r\n            state.nodeStates = state.nodeStates.filter((val) => val.id !== action.payload.id);\r\n            state.nodeStates.forEach((element) => {\r\n                element.outputs = element.outputs.filter((val) => val.id !== action.payload.id);\r\n                element.inputs = element.inputs.map((val) => {\r\n                    if (val) {\r\n                        if (val.id === action.payload.id) return null;\r\n                        return val\r\n                    }\r\n                }) as NodeInput[];\r\n            });\r\n            \r\n\r\n            return state;\r\n        }\r\n\r\n        case \"REMOVE_NODE_INPUT\": {\r\n\r\n            let value = state.nodeStates.find((value) => {\r\n                return value.id === action.payload.id;\r\n            }) as NodeState;\r\n\r\n            if (value) {\r\n                value.inputs = value.inputs.map((val) => {\r\n                    if (val) {\r\n                        if (val.index === action.payload.inputs[0].index) {\r\n                            let el = state.nodeStates.find((el) => { return el.id === val.id; });\r\n                            if (el) {\r\n                                el.outputs = el.outputs.filter((_el) => {\r\n                                    if ((_el.id === value.id) && (_el.index === val.index)) {\r\n                                        return false;\r\n                                    };\r\n                                    return true;\r\n                                });\r\n\r\n                            }\r\n                            return null;\r\n                        };\r\n                        return val;\r\n                    };// value.inputs.map((val)\r\n                }) as NodeInput[];\r\n            };\r\n            \r\n\r\n            return state;\r\n        };\r\n\r\n        case \"UPDATE_NODE\": {\r\n            state.nodeStates.forEach((value, index, arr) => {\r\n                \r\n                \r\n                if (value.id === action.payload.id) {\r\n                    if (!value.props.refs)\r\n                        value.props.refs = action.payload.props.refs;\r\n                    if (action.payload.inputs[0].ref) {\r\n                        if (value.inputs[action.payload.inputs[0].index]) {\r\n\r\n                            let oldVal = arr.find((element) => value.inputs[action.payload.inputs[0].index].id === element.id)\r\n                            if (oldVal) {\r\n\r\n                                oldVal.outputs = oldVal.outputs.filter((elem) => {\r\n                                    if ((elem.id === action.payload.id))\r\n                                        if (elem.index === action.payload.inputs[0].index) {\r\n                                            return false;\r\n                                        }\r\n                                    return true;\r\n\r\n                                });\r\n                            }\r\n\r\n                        }\r\n                        // [0] because you can only dispatch one action at a time\r\n                        value.inputs[action.payload.inputs[0].index] = action.payload.inputs[0];\r\n                        const outputer = arr.find((value) => value.id === action.payload.inputs[0].id);\r\n                        if (outputer) {\r\n                            value.inputs[action.payload.inputs[0].index].inputData = outputer.props.nodeDataValue;\r\n                        }\r\n\r\n                        value.props.nodeDataValue = { value: value.computeNodeValueFn(state.nodeStates)[1] }\r\n                        updateNodeValue(arr, value);\r\n                    }\r\n                    value.outputs = value.outputs.filter((val) => { if (val.id) return true; return false; });\r\n                    if (action.payload.outputs[0].id) {\r\n                        value.outputs.push(action.payload.outputs[0]);\r\n                    }\r\n                    return;\r\n                }\r\n            });\r\n            \r\n\r\n            return state;\r\n        }\r\n\r\n        case \"UPDATE_OUTPUT_TYPE\": {\r\n            let activeNode = state.nodeStates.find((val) => val.id === action.payload.id);\r\n            if (activeNode)\r\n                activeNode.nodeDataType = action.payload.nodeDataType;\r\n            \r\n\r\n            return state;\r\n        }\r\n\r\n        case \"UPDATE_PROPS\": {\r\n\r\n            let value = state.nodeStates.find((value) => { return value.id === action.payload.id; });\r\n            if (value) {\r\n                value.props.refs = action.payload.props.refs;\r\n                value.props.nodeDataValue = action.payload.props.nodeDataValue;\r\n                value.nodeDataType = action.payload.nodeDataType;\r\n                value.computeNodeValueFn = action.payload.computeNodeValueFn;\r\n                value.outputs.filter((val) => { if (val) return val.id; return false; });\r\n\r\n            }\r\n            \r\n\r\n            return state;\r\n        }\r\n\r\n        case \"UPDATE_NODE_VALUE\": {\r\n            state.nodeStates.forEach((element, index, arr) => {\r\n                element.outputs.filter((val) => { if (val) return val.id; return false; });\r\n                if (element.id == action.payload.id) {\r\n\r\n                    element.props.nodeDataValue = action.payload.props.nodeDataValue;\r\n                    updateNodeValue(arr, element);\r\n\r\n                }\r\n                return;\r\n            });\r\n            \r\n\r\n            return state;\r\n        }\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\reduxStore\\hooks.ts",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\ContextMenu.tsx",["173"],"import React, { useReducer, useRef } from \"react\";\r\nimport { defaultNodeState } from \"reducers/nodesFilter\";\r\nimport { generateUID } from \"Utils/helper\";\r\nimport { builtinsVariables, mathFuncs, matrixFuncs, textureSampling, trigonometryFuncs, vectorFuncs } from \"../../Graph/builtins\";\r\nimport { useAppDispatch } from \"../../reduxStore/hooks\";\r\n\r\ninterface ContextListItemProps {\r\n    itemName: NodeCategory;\r\n    lists: string[];\r\n    onClickFn: React.Dispatch<React.SetStateAction<number>>\r\n}\r\n\r\nconst IconDir = React.forwardRef<SVGSVGElement, {}>((props, ref) => {\r\n\r\n    return (\r\n        <svg ref={ref} className=\"IconDir\" fill=\"grey\" viewBox=\"0 0 20 20\" width=\"15\" height=\"15\">\r\n            <path d=\"M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z\">\r\n            </path>\r\n        </svg>\r\n    );\r\n});\r\n\r\n\r\nconst ContextListItem = React.forwardRef<HTMLDivElement, ContextListItemProps>((props, ref) => {\r\n    const itemsRef = useRef(HTMLDivElement.prototype);\r\n    const iconRef = useRef(SVGSVGElement.prototype);\r\n\r\n    const dispatch = useAppDispatch();\r\n\r\n    const toggleListItems = () => {\r\n        const elem = itemsRef.current;\r\n        const icon = iconRef.current;\r\n        icon.classList.toggle(\"Open\");\r\n        elem.classList.toggle(\"Active\");\r\n    }\r\n\r\n    return (\r\n        <div className=\"ContexListItem\">\r\n            <div className=\"Menu\" onClick={toggleListItems}><IconDir ref={iconRef} />{props.itemName}</div>\r\n            <div ref={itemsRef} className=\"SubListContainer\">\r\n                {\r\n                    props.lists.map((el, index) => {\r\n                        return (\r\n                            <div\r\n                                key={`${index}`}\r\n                                id={el}\r\n                                className=\"SubListItem\"\r\n                                onClick={(event: React.MouseEvent) => {\r\n                                    props.onClickFn((nodeCount) => {\r\n                                        nodeCount += 1;\r\n                                        toggleListItems();\r\n                                        dispatch(\r\n                                            {\r\n                                                type: \"ADD_NODE\",\r\n                                                payload: { ...defaultNodeState, id: generateUID(), nodeName: el, props: { x: event.pageX, y: event.pageY, refs: null, nodeDataValue: { value: 0 } }, inputs: [], outputs: [] }\r\n                                            })\r\n                                        return nodeCount;\r\n                                    });\r\n\r\n                                }}>{el}\r\n                            </div>\r\n                        );\r\n                    })\r\n                }\r\n            </div>\r\n        </div>\r\n    );\r\n});\r\n\r\ninterface ContextMenuProps {\r\n    onClickFn: React.Dispatch<React.SetStateAction<number>>\r\n}\r\n\r\ntype NodeCategory = \"Builtins\" | \"Data Types\" | \"Math\" | \"Trigonometry\" | \"Vector\" | \"Matrix\" | \"Texture\";\r\n\r\nexport const ContextMenu = React.forwardRef<HTMLDivElement, ContextMenuProps>((props, ref) => {\r\n    return (\r\n        <div ref={ref} className=\"ContextMenu\">\r\n            <div className=\"ContextTitle\">Add Node</div>\r\n            <div className=\"ContextList\">\r\n                <ContextListItem key={\"Builtins\"} onClickFn={props.onClickFn} itemName=\"Builtins\" lists={builtinsVariables} />\r\n                <ContextListItem key={\"Data Types\"} onClickFn={props.onClickFn} itemName=\"Data Types\" lists={[\"Integer\", \"Float\", \"Boolean\", \"Vector2\", \"Vector3\", \"Vector4\", \"Matrix3\", \"Matrix4\"]} />\r\n                <ContextListItem key={\"Math\"} onClickFn={props.onClickFn} itemName=\"Math\" lists={mathFuncs} />\r\n                <ContextListItem key={\"Trigonometry\"} onClickFn={props.onClickFn} itemName=\"Trigonometry\" lists={trigonometryFuncs} />\r\n                <ContextListItem key={\"Vector\"} onClickFn={props.onClickFn} itemName=\"Vector\" lists={vectorFuncs} />\r\n                <ContextListItem key={\"Matrix\"} onClickFn={props.onClickFn} itemName=\"Matrix\" lists={matrixFuncs} />\r\n                <ContextListItem key={\"Texture\"} onClickFn={props.onClickFn} itemName=\"Texture\" lists={textureSampling} />\r\n            </div>\r\n        </div>\r\n    )\r\n});\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\Graph\\builtins.ts",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\Builtins\\Builtins.tsx",["174"],"import React, { useRef } from \"react\";\r\nimport { NodeState } from \"reducers/nodesFilter\";\r\nimport { ContentContainer } from \"../ContentContainer\";\r\nimport { ConnectorNode } from \"../InOutNode\";\r\nimport { Node, NodeProps } from \"../Node\";\r\nimport { NodePanel } from \"../NodePanel\";\r\nimport { TitleBar } from \"../TitleBar\";\r\n\r\nexport const GLTexture0: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const outputValue = \"glTexture0\";\r\n    const glTexture0: NodeProps = {\r\n        ...props,\r\n        value: outputValue,\r\n        nodeRefs: {\r\n            id: props.id,\r\n            nodeCategory: \"Builtins\",\r\n            name: outputValue,\r\n            inputDataTypes: [],\r\n            outputDataType: \"Sampler2D\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: connectorRef,\r\n            nodeInputConnectorRef: null\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glTexture0}>\r\n            <NodePanel>\r\n                <TitleBar title=\"glTexture0\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node >\r\n    )\r\n}\r\n\r\nexport const GLTexture1: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const outputValue = \"glTexture1\";\r\n    const glTexture0: NodeProps = {\r\n        ...props,\r\n        value: outputValue,\r\n        nodeRefs: {\r\n            id: props.id,\r\n            nodeCategory: \"Builtins\",\r\n            name: outputValue,\r\n            inputDataTypes: [],\r\n            outputDataType: \"Sampler2D\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: connectorRef,\r\n            nodeInputConnectorRef: null\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glTexture0}>\r\n            <NodePanel>\r\n                <TitleBar title=\"glTexture1\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node >\r\n    )\r\n}\r\n\r\nexport const GLTexture2: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const outputValue = \"glTexture2\";\r\n    const glTexture0: NodeProps = {\r\n        ...props,\r\n        value: outputValue,\r\n        nodeRefs: {\r\n            id: props.id,\r\n            nodeCategory: \"Builtins\",\r\n            name: outputValue,\r\n            inputDataTypes: [],\r\n            outputDataType: \"Sampler2D\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: connectorRef,\r\n            nodeInputConnectorRef: null\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glTexture0}>\r\n            <NodePanel>\r\n                <TitleBar title=\"glTexture2\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node >\r\n    )\r\n}\r\n\r\n\r\nexport const GLTexture3: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const outputValue = \"glTexture3\";\r\n    const glTexture0: NodeProps = {\r\n        ...props,\r\n        value: outputValue,\r\n        nodeRefs: {\r\n            id: props.id,\r\n            nodeCategory: \"Builtins\",\r\n            name: outputValue,\r\n            inputDataTypes: [],\r\n            outputDataType: \"Sampler2D\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: connectorRef,\r\n            nodeInputConnectorRef: null\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glTexture0}>\r\n            <NodePanel>\r\n                <TitleBar title=\"glTexture3\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node >\r\n    )\r\n}\r\n\r\nexport const GlFragColor: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const outputValue = \"gl_FragColor\";\r\n\r\n    const computeNodeValueFn = (nodeState: NodeState[]) => {\r\n        let _nodeValue = \"\";\r\n        let _nodeValueVar = \"\"\r\n        let nodeElemIndex = -1;\r\n        let nodeElem = nodeState.find((value, index) => { nodeElemIndex = index; return value.id === props.id }) as NodeState;\r\n\r\n\r\n        for (let input of nodeElem?.inputs) {\r\n            if (input) {\r\n                if (input.id) {\r\n\r\n                    let inputNodeIndex = -1\r\n                    let inputNode = nodeState.find((value, index) => { inputNodeIndex = index; return value.id == input.id; }) as NodeState;\r\n\r\n                    _nodeValue = `${input.inputData.value}`;\r\n                    _nodeValueVar = `_${input.id}`\r\n\r\n                    if (inputNodeIndex > nodeElemIndex) {\r\n                        nodeState[inputNodeIndex] = nodeElem;\r\n                        nodeState[nodeElemIndex] = inputNode;\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n\r\n        return [_nodeValue, _nodeValueVar];\r\n    };\r\n\r\n    const fragCoordProps: NodeProps = {\r\n        ...props,\r\n        value: outputValue,\r\n        computeNodeValueFn,\r\n        nodeRefs: {\r\n            id: props.id,\r\n            nodeCategory: \"Builtins\",\r\n            name: outputValue,\r\n            inputDataTypes: [\"Vector4\"],\r\n            outputDataType: \"Vector4\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef:\r\n                connectorRef,\r\n            nodeInputConnectorRef: connectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...fragCoordProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"gl_FragColor\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Input\" ref={connectorRef} count={1} values={[\"In(4)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlFragCoord: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const outputValue = \"gl_FragCoord\";\r\n    const fragCoordProps: NodeProps = { ...props, value: outputValue, nodeRefs: { id: props.id, nodeCategory: \"Builtins\", name: outputValue, inputDataTypes: [], outputDataType: \"Vector4\", elementRef: ref, nodeOutputConnectorRef: connectorRef, nodeInputConnectorRef: null } };\r\n\r\n    return (\r\n        <Node {...fragCoordProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"gl_FragCoord\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(4)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n\r\nexport const GlFragDepth: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const outputValue = \"gl_FragDepth\";\r\n    const depthProps: NodeProps = { ...props, value: outputValue, nodeRefs: { id: props.id, nodeCategory: \"Builtins\", name: outputValue, inputDataTypes: [], outputDataType: \"Float\", elementRef: ref, nodeOutputConnectorRef: connectorRef, nodeInputConnectorRef: null } };\r\n\r\n    return (\r\n        <Node {...depthProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"gl_FragDepth\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    );\r\n};\r\n\r\nexport const GlTime: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const outputValue = \"iTime\";\r\n    const timeProps: NodeProps = { ...props, value: outputValue, nodeRefs: { id: props.id, nodeCategory: \"Builtins\", name: outputValue, inputDataTypes: [], outputDataType: \"Float\", elementRef: ref, nodeOutputConnectorRef: connectorRef, nodeInputConnectorRef: null } };\r\n\r\n    return (\r\n        <Node {...timeProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"iTime\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    );\r\n};\r\n\r\nexport const GlResolution: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const outputValue = \"iResolution\";\r\n    const resProps: NodeProps = { ...props, value: outputValue, nodeRefs: { id: props.id, nodeCategory: \"Builtins\", name: outputValue, inputDataTypes: [], outputDataType: \"Vector2\", elementRef: ref, nodeOutputConnectorRef: connectorRef, nodeInputConnectorRef: null } };\r\n\r\n\r\n    return (\r\n        <Node {...resProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"iResolution\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(2)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlMouseCoords: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const outputValue = \"iMouseCoords\";\r\n    const mouseProps: NodeProps = { ...props, value: outputValue, nodeRefs: { id: props.id, nodeCategory: \"Builtins\", name: outputValue, inputDataTypes: [], outputDataType: \"Vector2\", elementRef: ref, nodeOutputConnectorRef: connectorRef, nodeInputConnectorRef: null } };\r\n\r\n\r\n    return (\r\n        <Node {...mouseProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"iMouseCoord\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(2)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\DataTypes\\DataTypes.tsx",["175"],"import React, { useRef } from \"react\";\r\nimport { BoolType, GLType, defaultNodeState, FloatType, IntType, NodeDispatch } from \"reducers/nodesFilter\";\r\nimport { useAppDispatch, useAppSelector } from \"reduxStore/hooks\";\r\nimport { computeNodeValue } from \"Utils/helper\";\r\nimport { ContentContainer } from \"../ContentContainer\";\r\nimport { TextInputNode, BoolInputNode, ConnectorNode } from \"../InOutNode\";\r\nimport { Node, NodeProps } from \"../Node\";\r\nimport { NodePanel } from \"../NodePanel\";\r\nimport { TitleBar } from \"../TitleBar\";\r\n\r\nconst vectorInputTypes: GLType[] = [\"Integer\", \"Float\"]\r\n\r\nexport const Integer: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeDispatch: React.Dispatch<NodeDispatch> = useAppDispatch()\r\n    let nodeValue: IntType = 0;\r\n    const intProps: NodeProps = { ...props, value: nodeValue.toString(), nodeRefs: { id: props.id, nodeCategory: \"Data Types\", name: \"Integer\", inputDataTypes: [], outputDataType: \"Integer\", elementRef: ref, nodeOutputConnectorRef: connectorRef, nodeInputConnectorRef: null } };\r\n\r\n    const onValueChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n        if (event.target.value) {\r\n            const value = Number(event.target.value);\r\n            if (value) {\r\n                nodeValue = value;\r\n                nodeDispatch({\r\n                    type: \"UPDATE_NODE_VALUE\",\r\n                    payload: {\r\n                        ...defaultNodeState,\r\n                        id: props.id,\r\n                        props: {\r\n                            x: 0, y: 0,\r\n                            refs: null,\r\n                            nodeDataValue: { value: value }\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    return (\r\n        <Node {...intProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"Integer\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n                <TextInputNode onChangeFn={onValueChanged} />\r\n            </NodePanel>\r\n        </Node>\r\n    );\r\n};\r\n\r\nexport const Boolean: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    let nodeValue: BoolType = false;\r\n    const boolProps: NodeProps = { ...props, value: nodeValue.toString(), nodeRefs: { id: props.id, nodeCategory: \"Data Types\", name: \"Boolean\", inputDataTypes: [], outputDataType: \"Boolean\", elementRef: ref, nodeOutputConnectorRef: connectorRef, nodeInputConnectorRef: null } };\r\n\r\n    const nodeDispatch: React.Dispatch<NodeDispatch> = useAppDispatch();\r\n\r\n    const onValueChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n        nodeValue = event.target.checked;\r\n        nodeDispatch({\r\n            type: \"UPDATE_NODE_VALUE\",\r\n            payload: {\r\n                ...defaultNodeState,\r\n                id: props.id,\r\n                props: {\r\n                    x: 0, y: 0,\r\n                    refs: null,\r\n                    nodeDataValue: { value: nodeValue }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    return (\r\n        <Node {...boolProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"Boolean\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n                <BoolInputNode onChangeFn={onValueChanged} />\r\n            </NodePanel>\r\n        </Node>\r\n    );\r\n};\r\n\r\n\r\nexport const Float: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const connectorRef = useRef(HTMLDivElement.prototype);\r\n    const EPSILON = 0.00001;\r\n    let nodeValue: FloatType = 0.0 + EPSILON;\r\n    const floatProps: NodeProps = { ...props, value: nodeValue.toString(), nodeRefs: { id: props.id, nodeCategory: \"Data Types\", name: \"Float\", inputDataTypes: [], outputDataType: \"Float\", elementRef: ref, nodeOutputConnectorRef: connectorRef, nodeInputConnectorRef: null } };\r\n\r\n    const nodeDispatch: React.Dispatch<NodeDispatch> = useAppDispatch();\r\n    const onValueChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n        if (event.target.value) {\r\n            const value = Number(event.target.value) + EPSILON;\r\n\r\n            if (value) {\r\n                nodeValue = value;\r\n                nodeDispatch({\r\n                    type: \"UPDATE_NODE_VALUE\",\r\n                    payload: {\r\n                        ...defaultNodeState,\r\n                        id: props.id,\r\n                        props: {\r\n                            x: 0, y: 0,\r\n                            refs: null,\r\n                            nodeDataValue: { value: value }\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n        }\r\n    }\r\n    return (\r\n        <Node {...floatProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"Float\" />\r\n                <ContentContainer flex={false}>\r\n                    <ConnectorNode type=\"Output\" ref={connectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n                <TextInputNode onChangeFn={onValueChanged} />\r\n            </NodePanel>\r\n        </Node>\r\n    );\r\n};\r\n\r\n\r\nexport const Vector2: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n\r\n    let nodeValue = \"vec2(0, 0)\";\r\n\r\n\r\n    const vector2Props: NodeProps = {\r\n        ...props,\r\n        value: nodeValue.toString(),\r\n        computeNodeValueFn: computeNodeValue(props.id, \"vec2\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Data Types\",\r\n            name: \"Vector2\",\r\n            inputDataTypes: vectorInputTypes,\r\n            outputDataType: \"Vector2\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node  {...vector2Props} >\r\n            <NodePanel>\r\n                <TitleBar title=\"Vector2\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"X(1)\", \"Y(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(2)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n\r\nexport const Vector3: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeState = useAppSelector((state) => state.nodesFilter.nodeStates);\r\n    let nodeValue = \"vec3(0, 0, 0)\";\r\n\r\n\r\n    const vector3Props: NodeProps = {\r\n        ...props,\r\n        value: nodeValue.toString(),\r\n        computeNodeValueFn: computeNodeValue(props.id, \"vec3\", 3),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Data Types\",\r\n            name: \"Vector3\",\r\n            inputDataTypes: vectorInputTypes,\r\n            outputDataType: \"Vector3\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...vector3Props}>\r\n            <NodePanel>\r\n                <TitleBar title=\"Vector3\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={3} values={[\"X(1)\", \"Y(1)\", \"Z(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(3)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n\r\nexport const Vector4: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n\r\n    let nodeValue = \"vec4(0, 0, 0, 0)\";\r\n\r\n    const vector4Props: NodeProps = {\r\n        ...props,\r\n        value: nodeValue.toString(),\r\n        computeNodeValueFn: computeNodeValue(props.id, \"vec4\", 4),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Data Types\",\r\n            name: \"Vector4\",\r\n            inputDataTypes: vectorInputTypes,\r\n            outputDataType: \"Vector4\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...vector4Props}>\r\n            <NodePanel>\r\n                <TitleBar title=\"Vector4\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={4} values={[\"X(1)\", \"Y(1)\", \"Z(1)\", \"W(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(4)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n\r\nexport const Matrix3: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n\r\n    // const nodeState = useAppSelector((state) => state.nodesFilter.nodeStates);\r\n    let nodeValue = \"mat3(vec3(0, 0, 0), vec3(0, 0, 0), vec3(0, 0, 0))\";\r\n\r\n\r\n    const mat3Props: NodeProps = {\r\n        ...props,\r\n        value: nodeValue.toString(),\r\n        computeNodeValueFn: computeNodeValue(props.id, \"mat3\", 3),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Data Types\",\r\n            name: \"Matrix3\",\r\n            inputDataTypes: [\"Vector3\"],\r\n            outputDataType: \"Matrix3\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n    ;\r\n\r\n    return (\r\n        <Node {...mat3Props}>\r\n            <NodePanel>\r\n                <TitleBar title=\"Matrix3\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={3} values={[\"M(3)\", \"M(3)\", \"M(3)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(3X3)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const Matrix4: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n\r\n    //const nodeState = useAppSelector((state) => state.nodesFilter.nodeStates);\r\n    let nodeValue = \"mat4(vec4(0, 0, 0, 0), vec4(0, 0, 0, 0), vec4(0, 0, 0, 0), vec4(0, 0, 0, 0))\";\r\n\r\n\r\n    const mat4Props: NodeProps = {\r\n        ...props,\r\n        value: nodeValue.toString(),\r\n        computeNodeValueFn: computeNodeValue(props.id, \"mat4\", 4),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Data Types\",\r\n            name: \"Matrix4\",\r\n            inputDataTypes: [\"Vector4\"],\r\n            outputDataType: \"Matrix4\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...mat4Props}>\r\n            <NodePanel>\r\n                <TitleBar title=\"Matrix4\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={4} values={[\"M(4)\", \"M(4)\", \"M(4)\", \"M(4)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(4X4)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\Utils\\getNodeComponent.tsx",[],"C:\\Users\\rheen\\Documents\\Templates\\src\\Utils\\helper.ts",["176","177"],"import { GLType, NodeState, UID } from \"reducers/nodesFilter\";\r\n\r\nlet generatedUID: UID[] = []\r\nconst characterList = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"i\", \"j\", \"k\", \"l\"];\r\n\r\nconst getRandom = (min: number, max: number) => {\r\n    return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\r\n}\r\n\r\nconst getRandomInt = (min: number, max: number) => {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\r\n}\r\n\r\n\r\nexport const generateUID = () => {\r\n    var uid = \"\"\r\n    let uidLength = 15;\r\n    while (uidLength) {\r\n        var char = getRandomInt(0, 10);\r\n        if (getRandom(0, 10) <= 5) {\r\n            uid += characterList[char]\r\n        }\r\n        else {\r\n            uid += getRandomInt(0, 10);\r\n        }\r\n        uidLength--;\r\n    }\r\n\r\n    if (generatedUID.find((val) => val == uid)) {\r\n        generateUID();\r\n    }\r\n    generatedUID.push(uid);\r\n    return uid;\r\n}\r\n\r\n\r\nexport const swap = (a: any, b: any) => {\r\n    let [temp1, temp2] = [a, b];\r\n    a = temp2;\r\n    b = temp1;\r\n}\r\n\r\n/**\r\n * Helper function that calculates value of an element based on the supplied input\r\n * @param id computed element id\r\n * @param prefixVal element return type i.e `vec2`\r\n * @param count element input count i.e `vec2(1, 1)`\r\n * @param delimeter element separator i.e \",\" \"+\"\r\n * @returns computed element value based on input supplied\r\n */\r\nexport const computeNodeValue = (id: UID, prefixVal: string, count: number, delimeter = \",\", swap = false) => {\r\n    return (nodeState: NodeState[]): string[] => {\r\n\r\n        let nodeIndex = -1;\r\n        let node = nodeState.find((element, index) => {\r\n            if (element.id === id) {\r\n                nodeIndex = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        }) as NodeState;\r\n\r\n        let nodeValue = prefixVal + \"(\";\r\n        let nodeValueVar = prefixVal + \"(\";\r\n\r\n        if (node) {\r\n            if (count === 1) {\r\n                nodeValue += `${node.inputs[0].inputData.value})`;\r\n                nodeValueVar += `_${node.inputs[0].id})`;\r\n\r\n                let inputNodeIndex = -1;\r\n                const nodeInput = nodeState.find((value, index) => {\r\n                    if (value.id === node.inputs[0].id) {\r\n                        inputNodeIndex = index;\r\n                        return true;\r\n                    };\r\n\r\n                    return false;\r\n                }) as NodeState;\r\n\r\n\r\n                if (inputNodeIndex > nodeIndex) {\r\n                    nodeState[nodeIndex] = nodeInput;\r\n                    nodeState[inputNodeIndex] = node;\r\n                }\r\n\r\n                return [nodeValue, nodeValueVar];\r\n            }\r\n\r\n            let highestInputIndex = 0;\r\n            for (let i = 0; i < count; i++) {\r\n                let val = node.inputs[i];\r\n                let inputNodeIndex = -1;\r\n\r\n                const nodeInput = nodeState.find((value, index) => {\r\n                    if (value) {\r\n                        if (node.inputs[i]) {\r\n                            if (value.id === node.inputs[i].id) {\r\n                                inputNodeIndex = index;\r\n                                return true;\r\n                            };\r\n\r\n                        }\r\n                    }\r\n\r\n\r\n                    return false;\r\n                }) as NodeState;\r\n\r\n                if (!nodeInput)\r\n                    continue;\r\n\r\n                if (inputNodeIndex > highestInputIndex) {\r\n                    highestInputIndex = inputNodeIndex;\r\n                }\r\n\r\n                if (val) {\r\n                    nodeValue += val.inputData.value;\r\n                    nodeValueVar += `_${node.inputs[i].id}`;\r\n                }\r\n                else {\r\n                    nodeValue += 0;\r\n                    nodeValueVar += 0;\r\n                }\r\n\r\n                if (i != count - 1) {\r\n                    nodeValue += delimeter;\r\n                    nodeValueVar += delimeter;\r\n                }\r\n\r\n                if (highestInputIndex > nodeIndex && i === (count - 1)) {\r\n                    nodeState[highestInputIndex] = node;\r\n                    nodeState[nodeIndex] = nodeInput;\r\n                }\r\n            }\r\n            nodeValue += \")\";\r\n            nodeValueVar += \")\";\r\n\r\n            return swap ? [nodeValue, nodeValueVar] : [nodeValueVar, nodeValue];\r\n        }\r\n        nodeValue += \")\";\r\n        nodeValueVar += \")\";\r\n\r\n        return swap ? [nodeValue, nodeValueVar] : [nodeValueVar, nodeValue];\r\n    }\r\n}\r\n\r\n/**\r\n * Flattens Dom element tree to a single Array\r\n */\r\nexport const flattenElementTree = (element: Element, result: Element[]) => {\r\n    for (var i = 0; i < element.childElementCount; i++) {\r\n\r\n        var val = element.children[i];\r\n        if (val.childElementCount > 0) {\r\n            flattenElementTree(val, result);\r\n        }\r\n        else {\r\n            result.push(val);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Helper Vector2 interface\r\n */\r\nexport interface Vec2 {\r\n    x: number,\r\n    y: number,\r\n}\r\n\r\n/**\r\n * Returns length of Vector2 object\r\n */\r\nexport const Vec2length = (vec: Vec2): number => {\r\n    return Math.sqrt(vec.x * vec.x + vec.y * vec.y);\r\n}\r\n\r\n/**\r\n * Returns Distance of DOM element Rect to mouse position, useful for checking if mouse collides with a DOM element\r\n * @param mouse mouse position\r\n * @param bb DOM element bounding box or DOMRect\r\n */\r\nexport const getDistanceToMouse = (mouse: Vec2, bb: DOMRect): number => {\r\n    const offset: Vec2 = { x: ((bb.x + bb.right) * 0.5) - mouse.x, y: ((bb.y + bb.bottom) * 0.5) - mouse.y };\r\n    const offsetAbs: Vec2 = { x: Math.abs(offset.x), y: Math.abs(offset.y) };\r\n    const dir: Vec2 = { x: Math.max(0, offsetAbs.x - (bb.width / 2)), y: Math.max(0, offsetAbs.y - (bb.height / 2)) };\r\n    return Vec2length(dir);\r\n}\r\n\r\n\r\nexport const getGLGraphToGLSLDataType = (glGraphType: GLType) => {\r\n    switch (glGraphType) {\r\n        case \"Boolean\": return \"bool\";\r\n        case \"Integer\": return \"int\";\r\n        case \"Float\": return \"float\";\r\n        case \"Vector2\": return \"vec2\";\r\n        case \"Vector3\": return \"vec3\";\r\n        case \"Vector4\": return \"vec4\";\r\n        case \"Matrix3\": return \"mat3\";\r\n        case \"Matrix4\": return \"mat4\";\r\n    }\r\n}\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\GraphComponents\\GLFuncs\\GLFuncs.tsx",["178","179","180","181","182","183","184","185","186"],"import React, { useRef, useState } from \"react\";\r\nimport { defaultNodeState, GLType, NodeState } from \"reducers/nodesFilter\";\r\nimport { useAppDispatch, useAppSelector } from \"reduxStore/hooks\";\r\nimport { computeNodeValue } from \"Utils/helper\";\r\nimport { ContentContainer } from \"../ContentContainer\";\r\nimport { ConnectorNode, TextInputNode } from \"../InOutNode\";\r\nimport { Node, NodeProps } from \"../Node\";\r\nimport { NodePanel } from \"../NodePanel\";\r\nimport { TitleBar } from \"../TitleBar\";\r\n\r\nconst numDataTypes: GLType[] = [\"Integer\", \"Float\"]\r\nconst vecDataTypes: GLType[] = [\"Vector2\", \"Vector3\", \"Vector4\"]\r\nconst matDataTypes: GLType[] = [\"Matrix3\", \"Matrix4\"]\r\nconst allDataTypes: GLType[] = [...numDataTypes, ...vecDataTypes, ...matDataTypes];\r\n\r\nexport const GlTexture: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"texture\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        computeNodeValueFn: computeNodeValue(props.id, nodeName, 2, \",\", true),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Texture\",\r\n            inputDataTypes: [...vecDataTypes, \"Sampler2D\"],\r\n            outputDataType: \"Vector4\",\r\n            name: \"texture\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef,\r\n\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"In(1)\", \"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlTexelFetch: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"texelFetch\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        computeNodeValueFn: computeNodeValue(props.id, nodeName, 2, \",\", true),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Texture\",\r\n            inputDataTypes: [...vecDataTypes, \"Sampler2D\"],\r\n            outputDataType: \"Vector4\",\r\n            name: \"texelFetch\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef,\r\n\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"In(1)\", \"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlTextureGather: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"textureGather\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        computeNodeValueFn: computeNodeValue(props.id, nodeName, 2, \",\", true),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Texture\",\r\n            inputDataTypes: [...vecDataTypes, \"Sampler2D\"],\r\n            outputDataType: \"Vector4\",\r\n            name: \"textureGather\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef,\r\n\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"In(1)\", \"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlTextureProj: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"textureProj\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        computeNodeValueFn: computeNodeValue(props.id, nodeName, 2, \",\", true),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Texture\",\r\n            inputDataTypes: [...vecDataTypes, \"Sampler2D\"],\r\n            outputDataType: \"Vector4\",\r\n            name: \"textureProj\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef,\r\n\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"In(1)\", \"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlTextureSize: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"textureSize\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        computeNodeValueFn: computeNodeValue(props.id, nodeName, 1, \",\", true),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Texture\",\r\n            inputDataTypes: [...vecDataTypes, \"Sampler2D\"],\r\n            outputDataType: \"Vector2\",\r\n            name: \"textureSize\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef,\r\n\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n\r\nexport const GlAdd: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"add\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"\", 2, \"+\"),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: \"add\",\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef,\r\n\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"In(1)\", \"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlSubstract: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"substract\";\r\n    let nodeValue = \"\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"\", 2, \"-\"),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"In(1)\", \"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlMultiply: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"multiply\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"\", 2, \"*\"),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: allDataTypes,\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"multiply\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"In(1)\", \"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlDivide: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"divide\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"\", 2, \"/\"),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: allDataTypes,\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"divide\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"In(1)\", \"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlAbs: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"abs\";\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"abs\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"abs\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlCeil: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"ceil\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"ceil\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"ceil\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlFloor: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"floor\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"floor\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"floor\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlFract: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"fract\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"fract\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"fract\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlInvSqrt: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"inversesqrt\";\r\n\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"inversesqrt\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"inversesqrt\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlInf: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"isinf\";\r\n\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"isinf\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Boolean\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"isinf\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlNan: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"isnan\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"isnan\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Boolean\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"isnan\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlMod: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"mod\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"mod\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"mod\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"X(1)\", \"Y(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlMin: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"min\";\r\n\r\n    let nodeValue = \"min(0, 0)\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"min\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"min\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"X(1)\", \"Y(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlMax: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"max\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"max\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"max\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"X(1)\", \"Y(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlLog: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"log\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"log\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"log\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n\r\nexport const GlLog2: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"log2\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"log2\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"log2\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlNoise: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"noise\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"noise\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlPow: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"pow\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"pow\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"pow\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"X(1)\", \"Y(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n\r\nexport const GlRound: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"round\";\r\n\r\n    let nodeValue = \"\";\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"round\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"round\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlRoundEven: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"roundEven\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"roundEven\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title=\"roundEven\" />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n\r\nexport const GlSign: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"sign\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"sign\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlSmoothstep: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"smoothstep\";\r\n\r\n\r\n    let nodeValue = \"\";\r\n\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"smoothstep\", 3),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={3} values={[\"E1(1)\", \"E2(1)\", \"X(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlSqrt: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"sqrt\";\r\n\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"sqrt\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlStep: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"step\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"step\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"E1(1)\", \"X(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlTrunc: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"trunc\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"trunc\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlClamp: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"clamp\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"clamp\", 3),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={3} values={[\"Val(1)\", \"min(1)\", \"max(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlExp: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"exp\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"exp\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"Val(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlExp2: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"exp2\";\r\n\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"exp2\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n// Trigonometry Functions\r\nexport const GlAcos: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"acos\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"acos\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlAtan: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"atan\";\r\n\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"atan\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlTan: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"tan\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"atan\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlTanH: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"tanh\";\r\n\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"tanh\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlAtanH: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"atanh\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"atanh\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlCos: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"cos\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"cos\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlCosH: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"cosh\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"cosh\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlAcosH: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"acosh\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"acosh\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    ;\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlSin: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"sin\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"sin\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlSinH: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"sinh\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"sinh\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlASin: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"asin\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"asin\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlASinH: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"asinh\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"asinh\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlDegrees: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"degrees\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"degrees\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlRadians: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"radians\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"radians\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Trigonometry\",\r\n            inputDataTypes: [...numDataTypes, ...vecDataTypes],\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"In(1)\",]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n// Vectors Manipulation\r\nexport const GlCross: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"cross\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"cross\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Vector\",\r\n            inputDataTypes: vecDataTypes,\r\n            outputDataType: \"Vector\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"X(1)\", \"Y(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlDot: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"dot\";\r\n    let nodeValue = \"\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"dot\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Vector\",\r\n            inputDataTypes: vecDataTypes,\r\n            outputDataType: \"Float\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"X(1)\", \"Y(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlDistance: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"distance\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"distance\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Vector\",\r\n            inputDataTypes: vecDataTypes,\r\n            outputDataType: \"Vector\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"X(1)\", \"Y(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlEqual: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"equal\";\r\n    let nodeValue = \"\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"equal\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Vector\",\r\n            inputDataTypes: allDataTypes,\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"X(1)\", \"Y(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlNotEqual: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"notEqual\";\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"notEqual\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Vector\",\r\n            inputDataTypes: allDataTypes,\r\n            outputDataType: \"Any\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"X(1)\", \"Y(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlFaceForward: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"faceforward\";\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"faceforward\", 3),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Vector\",\r\n            inputDataTypes: vecDataTypes,\r\n            outputDataType: \"Vector\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={3} values={[\"X(1)\", \"Y(1)\", \"R(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlLength: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"length\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"length\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Vector\",\r\n            inputDataTypes: vecDataTypes,\r\n            outputDataType: \"Float\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"X(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlNormalize: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"normalize\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"normalize\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Vector\",\r\n            inputDataTypes: vecDataTypes,\r\n            outputDataType: \"Vector\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"X(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlReflect: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"reflect\";\r\n    let nodeValue = \"\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"reflect\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Vector\",\r\n            inputDataTypes: vecDataTypes,\r\n            outputDataType: \"Vector\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"I(1)\", \"N(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlRefract: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"refract\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"refract\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Vector\",\r\n            inputDataTypes: vecDataTypes,\r\n            outputDataType: \"Vector\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"I(1)\", \"N(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\n// Matrix Manipulation\r\n\r\nexport const GlDeterminant: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"determinant\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"determinant\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Matrix\",\r\n            inputDataTypes: matDataTypes,\r\n            outputDataType: \"Matrix\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"M(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlInverse: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"inverse\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"inverse\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Matrix\",\r\n            inputDataTypes: matDataTypes,\r\n            outputDataType: \"Matrix\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"M(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlTranspose: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"transpose\";\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"transpose\", 1),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Matrix\",\r\n            inputDataTypes: matDataTypes,\r\n            outputDataType: \"Matrix\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"M(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlMatCompMult: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"matrixCompMult\";\r\n    let nodeValue = \"\";\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"matrixCompMult\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Matrix\",\r\n            inputDataTypes: matDataTypes,\r\n            outputDataType: \"Matrix\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"M1(1)\", \"M2(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlOuterProduct: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeName = \"outerProduct\";\r\n\r\n    let nodeValue = \"\";\r\n\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue,\r\n        computeNodeValueFn: computeNodeValue(props.id, \"outerProduct\", 2),\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Matrix\",\r\n            inputDataTypes: matDataTypes,\r\n            outputDataType: \"Matrix\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={2} values={[\"V1(1)\", \"V2(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n\r\nexport const GlSelect: React.FC<NodeProps> = (props) => {\r\n    const ref = useRef(HTMLDivElement.prototype);\r\n    const outputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const inputConnectorRef = useRef(HTMLDivElement.prototype);\r\n    const nodeDispatch = useAppDispatch();\r\n    const nodeStates = useAppSelector((state) => state.nodesFilter.nodeStates)\r\n    const nodeName = \"select\";\r\n\r\n    const selectedIndex = useRef(\"x\");\r\n    const nodeValue = useRef(\"\");\r\n    //const [selectedIndex, setSelectedIndex] = useState({ value: \"x\" });\r\n\r\n    const computeNodeValueFn = (nodeState: NodeState[], s = \"\") => {\r\n        let _nodeValue = \"\";\r\n        let _nodeValueVar = \"\"\r\n        let nodeElemIndex = -1;\r\n        let nodeElem = nodeState.find((value, index) => { nodeElemIndex = index; return value.id === props.id }) as NodeState;\r\n        nodeValue.current = \"\";\r\n\r\n        for (let input of nodeElem?.inputs) {\r\n            if (input) {\r\n                if (input.id) {\r\n\r\n                    let inputNodeIndex = -1\r\n                    let inputNode = nodeState.find((value, index) => { inputNodeIndex = index; return value.id == input.id; }) as NodeState;\r\n\r\n                    _nodeValue = `${input.inputData.value}.${selectedIndex.current}`;\r\n                    _nodeValueVar = `_${input.id}.${selectedIndex.current}`\r\n\r\n                    if (inputNodeIndex > nodeElemIndex) {\r\n                        nodeState[inputNodeIndex] = nodeElem;\r\n                        nodeState[nodeElemIndex] = inputNode;\r\n                    }\r\n                    nodeValue.current = _nodeValue;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return [_nodeValue, _nodeValueVar];\r\n    };\r\n\r\n    const glProps: NodeProps = {\r\n        ...props,\r\n        value: nodeValue.current,\r\n        computeNodeValueFn,\r\n        nodeRefs:\r\n        {\r\n            id: props.id,\r\n            nodeCategory: \"Math\",\r\n            inputDataTypes: [...vecDataTypes],\r\n            outputDataType: \"Float\",\r\n            name: nodeName,\r\n            elementRef: ref,\r\n            nodeOutputConnectorRef: outputConnectorRef,\r\n            nodeInputConnectorRef: inputConnectorRef\r\n        }\r\n    };\r\n\r\n    const onValueChanged = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n        if (event.target.value) {\r\n\r\n            const value = event.target.value.toLowerCase();\r\n\r\n            if (value === \"x\" || value === \"r\") {\r\n                selectedIndex.current = \"x\"\r\n                //  setSelectedIndex({ value: \"x\" });\r\n            }\r\n\r\n            else if (value === \"y\" || value === \"g\") {\r\n                selectedIndex.current = \"y\"\r\n                //   setSelectedIndex({ value: \"y\" });\r\n            }\r\n            else if (value === \"z\" || value === \"b\") {\r\n                selectedIndex.current = \"z\"\r\n                //        setSelectedIndex({ value: \"z\" });\r\n            }\r\n            else if (value === \"w\" || value === \"a\") {\r\n                selectedIndex.current = \"w\"\r\n                //   setSelectedIndex({ value: \"w\" });\r\n            };\r\n\r\n\r\n            let s = \"\";\r\n            const [_nodeValue, _nodeValueVar] = computeNodeValueFn(nodeStates, s);\r\n            console.log(_nodeValueVar);\r\n\r\n            nodeDispatch({\r\n                type: \"UPDATE_NODE_VALUE\",\r\n                payload: {\r\n                    ...defaultNodeState,\r\n                    id: props.id,\r\n                    props: {\r\n                        x: 0, y: 0,\r\n                        refs: null,\r\n                        nodeDataValue: { value: _nodeValueVar }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    return (\r\n        <Node {...glProps}>\r\n            <NodePanel>\r\n                <TitleBar title={nodeName} />\r\n                <ContentContainer flex={true}>\r\n                    <ConnectorNode type=\"Input\" ref={inputConnectorRef} count={1} values={[\"V1(1)\", \"V2(1)\"]} />\r\n                    <ConnectorNode type=\"Output\" ref={outputConnectorRef} count={1} values={[\"Out(1)\"]} />\r\n                </ContentContainer>\r\n                <TextInputNode onChangeFn={onValueChanged} />\r\n            </NodePanel>\r\n        </Node>\r\n    )\r\n};\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\Componets\\Menus.tsx",["187","188","189"],"import { textureViewPanelRef } from \"App\";\r\nimport React, { useRef } from \"react\";\r\nimport { useAppSelector } from \"reduxStore/hooks\";\r\nimport { getGLGraphToGLSLDataType } from \"Utils/helper\";\r\nimport { Renderer } from \"WebGL/GLRenderer\";\r\nimport { GLTexture2D } from \"WebGL/Texture\";\r\nimport { showContext } from \"./Tabs/GraphTab\";\r\n\r\nlet compiledCode = \"\"\r\n\r\n\r\n\r\nconst CodeIcon = () => {\r\n    return (\r\n        <svg className=\"svg-icon\" focusable=\"false\" viewBox=\"0 0 30 30\" aria-hidden=\"true\">\r\n            <path d=\"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z\"></path>\r\n        </svg>\r\n    )\r\n}\r\nexport const CompileButton = () => {\r\n    const nodeState = useAppSelector((state) => state.nodesFilter.nodeStates);\r\n    let shaderCode = \"\";\r\n    const compileGraph = () => {\r\n        shaderCode = \"\";\r\n        nodeState.forEach((nodeElement) => {\r\n            if (nodeElement.nodeName != \"gl_FragColor\") {\r\n                if (nodeElement.nodeName != \"undefined\")\r\n                    shaderCode += `${getGLGraphToGLSLDataType(nodeElement.nodeDataType)} _${nodeElement.id} = ${nodeElement.props.nodeDataValue.value};\\n`;\r\n            }\r\n            else {\r\n                shaderCode += `gl_FragColor = ${nodeElement.props.nodeDataValue.value};`\r\n            }\r\n        });\r\n        compiledCode = Renderer.UpdateCompiledShader(shaderCode);\r\n    }\r\n\r\n    return (\r\n        <div className=\"CompileButton\" onClick={() => compileGraph()}>\r\n            <CodeIcon />\r\n            <div>Compile</div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport const AddNodeButton = () => {\r\n    const addNewNode = (event: React.MouseEvent) => {\r\n        const thisElem = event.currentTarget;\r\n        showContext({ x: thisElem.getBoundingClientRect().left, y: thisElem.getBoundingClientRect().bottom + 20 });\r\n    }\r\n\r\n    return (\r\n        <div className=\"AddButton\" onClick={addNewNode}>\r\n            <AddIcon />\r\n            <div>Add Node</div>\r\n        </div>\r\n    )\r\n}\r\n\r\nconst AddIcon = () => {\r\n    return (\r\n        <svg className=\"svg-icon\" focusable=\"false\" viewBox=\"0 0 30 30 \" aria-hidden=\"true\">\r\n            <path d=\"M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z\"></path>\r\n        </svg>\r\n    );\r\n}\r\n\r\n\r\n\r\nexport const UploadTexture = () => {\r\n    const handleClick = (event: React.MouseEvent) => {\r\n        textureViewPanelRef.current?.classList.toggle(\"Active\");\r\n    }\r\n\r\n    return (\r\n        <div className=\"AddButton\" onClick={handleClick}>\r\n            <AddIcon />\r\n            <div>Upload Texture</div>\r\n        </div>\r\n    )\r\n}\r\n\r\n\r\nexport const Texture: React.FC<{ index: number }> = (props) => {\r\n    const fileInputRef = useRef<HTMLInputElement>(HTMLInputElement.prototype);\r\n    const imgRef = useRef(HTMLImageElement.prototype);\r\n\r\n    const handleImageFile = () => {\r\n        const inputElem = fileInputRef.current;\r\n        const imgElem = imgRef.current;\r\n        const imageFile = inputElem.files as FileList;\r\n        if (imageFile.item(0)) {\r\n            imgElem.src = URL.createObjectURL(imageFile.item(0) as File);\r\n            imgElem.onload = () => {\r\n                GLTexture2D.UpdateTexture(props.index, imgElem);\r\n                URL.revokeObjectURL(inputElem.src);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n\r\n    return (\r\n        <div className=\"TextureView\">\r\n            <div className=\"TextureViewInput\">\r\n                <input onChange={handleImageFile} accept=\".png\" ref={fileInputRef} type=\"file\" name=\"\" id=\"\" className=\"TextureInput\" />\r\n                <img ref={imgRef} src=\"\" alt=\"\" width={\"100%\"} />\r\n            </div>\r\n            <button onClick={(event) => {\r\n                const inputElem = fileInputRef.current;\r\n                inputElem.click();\r\n                event.preventDefault();\r\n            }}>Upload</button>\r\n        </div >\r\n    )\r\n}\r\n\r\n\r\nexport const TextureViewPanel = React.forwardRef<HTMLDivElement, any>((props, ref) => {\r\n    return (\r\n        <div ref={ref} className=\"TextureViewPanel\">\r\n            <Texture key={0} index={0} />\r\n            <Texture key={1} index={1} />\r\n            <Texture key={2} index={2} />\r\n            <Texture key={3} index={3} />\r\n\r\n        </div>\r\n    )\r\n});\r\n\r\n\r\n// export const CodeView = () => {\r\n//     return (\r\n//         <div className={\"CodeView\"}>\r\n//             <code>\r\n//                 {\r\n\r\n//                 }\r\n//             </code>\r\n//         </div>\r\n//     )\r\n// }\r\n\r\n\r\n// export const SaveButton = () => {\r\n\r\n//     return (\r\n//         <div className=\"SaveButton\" onClick={() => saveToStorage}>\r\n//             <Save viewBox={\"0 0 30 30\"} />\r\n\r\n//             <div >\r\n//                 Save\r\n//             </div>\r\n//         </div >\r\n//     )\r\n// }\r\n\r\n\r\n// export const ShowCompiledCode = () => {\r\n//     const addNewNode = () => {\r\n\r\n//     }\r\n\r\n//     return (\r\n//         //  <div className=\"CompileButton\" onClick={() => addNewNode}>\r\n//         <SaveIcon />\r\n//         //    Show Code\r\n//         //    </div>\r\n//     )\r\n// }\r\n\r\n","C:\\Users\\rheen\\Documents\\Templates\\src\\WebGL\\Texture.ts",[],{"ruleId":"190","severity":1,"message":"191","line":8,"column":8,"nodeType":"192","messageId":"193","endLine":8,"endColumn":16},{"ruleId":"194","replacedBy":"195"},{"ruleId":"196","replacedBy":"197"},{"ruleId":"190","severity":1,"message":"198","line":1,"column":10,"nodeType":"192","messageId":"193","endLine":1,"endColumn":13},{"ruleId":"190","severity":1,"message":"199","line":2,"column":21,"nodeType":"192","messageId":"193","endLine":2,"endColumn":27},{"ruleId":"200","severity":1,"message":"201","line":20,"column":8,"nodeType":"202","endLine":20,"endColumn":10,"suggestions":"203"},{"ruleId":"190","severity":1,"message":"204","line":46,"column":7,"nodeType":"192","messageId":"193","endLine":46,"endColumn":20},{"ruleId":"190","severity":1,"message":"205","line":275,"column":35,"nodeType":"192","messageId":"193","endLine":275,"endColumn":48},{"ruleId":"190","severity":1,"message":"206","line":798,"column":21,"nodeType":"192","messageId":"193","endLine":798,"endColumn":26},{"ruleId":"207","severity":1,"message":"208","line":863,"column":22,"nodeType":"209","messageId":"210","endLine":863,"endColumn":24},{"ruleId":"207","severity":1,"message":"211","line":982,"column":24,"nodeType":"209","messageId":"210","endLine":982,"endColumn":26},{"ruleId":"212","severity":1,"message":"213","line":1115,"column":116,"nodeType":"214","messageId":"215","endLine":1115,"endColumn":118},{"ruleId":"207","severity":1,"message":"211","line":1115,"column":145,"nodeType":"209","messageId":"210","endLine":1115,"endColumn":147},{"ruleId":"207","severity":1,"message":"211","line":1115,"column":174,"nodeType":"209","messageId":"210","endLine":1115,"endColumn":176},{"ruleId":"190","severity":1,"message":"216","line":1132,"column":12,"nodeType":"192","messageId":"193","endLine":1132,"endColumn":21},{"ruleId":"200","severity":1,"message":"217","line":1139,"column":8,"nodeType":"202","endLine":1139,"endColumn":10,"suggestions":"218"},{"ruleId":"190","severity":1,"message":"219","line":1156,"column":21,"nodeType":"192","messageId":"193","endLine":1156,"endColumn":40},{"ruleId":"220","severity":1,"message":"221","line":1166,"column":29,"nodeType":"222","messageId":"223","endLine":1169,"endColumn":30},{"ruleId":"190","severity":1,"message":"224","line":1,"column":17,"nodeType":"192","messageId":"193","endLine":1,"endColumn":25},{"ruleId":"190","severity":1,"message":"225","line":7,"column":11,"nodeType":"192","messageId":"193","endLine":7,"endColumn":22},{"ruleId":"207","severity":1,"message":"211","line":39,"column":26,"nodeType":"209","messageId":"210","endLine":39,"endColumn":28},{"ruleId":"226","severity":1,"message":"227","line":33,"column":22,"nodeType":"192","messageId":"228","endLine":33,"endColumn":23},{"ruleId":"194","replacedBy":"229"},{"ruleId":"196","replacedBy":"230"},{"ruleId":"190","severity":1,"message":"199","line":2,"column":10,"nodeType":"192","messageId":"193","endLine":2,"endColumn":16},{"ruleId":"200","severity":1,"message":"231","line":82,"column":8,"nodeType":"202","endLine":82,"endColumn":40,"suggestions":"232"},{"ruleId":"212","severity":1,"message":"233","line":156,"column":56,"nodeType":"214","messageId":"215","endLine":156,"endColumn":58},{"ruleId":"190","severity":1,"message":"234","line":174,"column":28,"nodeType":"192","messageId":"193","endLine":174,"endColumn":37},{"ruleId":"212","severity":1,"message":"235","line":217,"column":59,"nodeType":"214","messageId":"215","endLine":217,"endColumn":61},{"ruleId":"212","severity":1,"message":"235","line":236,"column":55,"nodeType":"214","messageId":"215","endLine":236,"endColumn":57},{"ruleId":"207","severity":1,"message":"211","line":334,"column":32,"nodeType":"209","messageId":"210","endLine":334,"endColumn":34},{"ruleId":"190","severity":1,"message":"236","line":1,"column":17,"nodeType":"192","messageId":"193","endLine":1,"endColumn":27},{"ruleId":"207","severity":1,"message":"211","line":151,"column":112,"nodeType":"209","messageId":"210","endLine":151,"endColumn":114},{"ruleId":"190","severity":1,"message":"237","line":178,"column":11,"nodeType":"192","messageId":"193","endLine":178,"endColumn":20},{"ruleId":"207","severity":1,"message":"211","line":31,"column":40,"nodeType":"209","messageId":"210","endLine":31,"endColumn":42},{"ruleId":"207","severity":1,"message":"208","line":128,"column":23,"nodeType":"209","messageId":"210","endLine":128,"endColumn":25},{"ruleId":"190","severity":1,"message":"224","line":1,"column":25,"nodeType":"192","messageId":"193","endLine":1,"endColumn":33},{"ruleId":"190","severity":1,"message":"234","line":22,"column":9,"nodeType":"192","messageId":"193","endLine":22,"endColumn":18},{"ruleId":"190","severity":1,"message":"234","line":60,"column":9,"nodeType":"192","messageId":"193","endLine":60,"endColumn":18},{"ruleId":"190","severity":1,"message":"234","line":98,"column":9,"nodeType":"192","messageId":"193","endLine":98,"endColumn":18},{"ruleId":"190","severity":1,"message":"234","line":136,"column":9,"nodeType":"192","messageId":"193","endLine":136,"endColumn":18},{"ruleId":"190","severity":1,"message":"234","line":174,"column":9,"nodeType":"192","messageId":"193","endLine":174,"endColumn":18},{"ruleId":"190","severity":1,"message":"234","line":213,"column":9,"nodeType":"192","messageId":"193","endLine":213,"endColumn":18},{"ruleId":"207","severity":1,"message":"211","line":2438,"column":112,"nodeType":"209","messageId":"210","endLine":2438,"endColumn":114},{"ruleId":"190","severity":1,"message":"238","line":2498,"column":20,"nodeType":"192","messageId":"193","endLine":2498,"endColumn":30},{"ruleId":"207","severity":1,"message":"208","line":26,"column":38,"nodeType":"209","messageId":"210","endLine":26,"endColumn":40},{"ruleId":"207","severity":1,"message":"208","line":27,"column":42,"nodeType":"209","messageId":"210","endLine":27,"endColumn":44},{"ruleId":"190","severity":1,"message":"239","line":34,"column":9,"nodeType":"192","messageId":"193","endLine":34,"endColumn":21},"@typescript-eslint/no-unused-vars","'reducers' is defined but never used.","Identifier","unusedVar","no-native-reassign",["240"],"no-negated-in-lhs",["241"],"'off' is defined but never used.","'useRef' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'canvasElement' and 'props'. Either include them or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.","ArrayExpression",["242"],"'DEFAULT_INDEX' is assigned a value but never used.","'inputDataType' is assigned a value but never used.","'index' is assigned a value but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","array-callback-return","Array.prototype.findIndex() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'nodeCount' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'nodesDispatch'. Either include it or remove the dependency array.",["243"],"'tryingToConnectNode' is assigned a value but never used.","no-lone-blocks","Block is redundant.","BlockStatement","redundantBlock","'useState' is defined but never used.","'WindowProps' is defined but never used.","@typescript-eslint/no-redeclare","'i' is already defined.","redeclared",["240"],["241"],"React Hook useEffect has missing dependencies: 'nodeDispatch', 'props.computeNodeValueFn', 'props.id', 'props.nodeRefs', and 'props.value'. Either include them or remove the dependency array.",["244"],"Array.prototype.find() expects a value to be returned at the end of arrow function.","'nodeValue' is assigned a value but never used.","Array.prototype.map() expects a value to be returned at the end of arrow function.","'useReducer' is defined but never used.","'nodeState' is assigned a value but never used.","'_nodeValue' is assigned a value but never used.","'compiledCode' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"245","fix":"246"},{"desc":"247","fix":"248"},{"desc":"249","fix":"250"},"Update the dependencies array to be: [canvasElement, props]",{"range":"251","text":"252"},"Update the dependencies array to be: [nodesDispatch]",{"range":"253","text":"254"},"Update the dependencies array to be: [nodeDispatch, props.computeNodeValueFn, props.id, props.nodeRefs, props.value]",{"range":"255","text":"256"},[669,671],"[canvasElement, props]",[63688,63690],"[nodesDispatch]",[3715,3747],"[nodeDispatch, props.computeNodeValueFn, props.id, props.nodeRefs, props.value]"]